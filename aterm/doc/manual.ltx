% vim:ts=4:sw=4:tw=75
\documentclass[a4paper,twoside]{article}

\usepackage{fullpage}
\usepackage{verbatim}
\usepackage{makeidx}

\makeindex

\newcommand{\ATlib}{ATerm Library}
\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}

%% notion of Symbol was changed to AFun, which matches specification.
\newcommand{\Symbol}{AFun}	

\newcommand{\ATtrue}{\mbox{\tt ATtrue}}
\newcommand{\ATfalse}{\mbox{\tt ATfalse}}
\newcommand{\main}{\mbox{\tt main}}
\newcommand{\ATinit}{\mbox{\tt ATinit}}
\newcommand{\ATprotect}{\mbox{\tt ATprotect}}
\newcommand{\ATprotectArray}{\mbox{\tt ATprotectArray}}

%\openout 15 functions.idx
%\openout 14 macros.idx

% \example{init.c} will input file "examples/init.c" in verbatim mode.
\newcommand{\example}[1]{
	\noindent\hrulefill
	\begin{small}
	\verbatiminput{examples/#1}
	\end{small}
	\hrulefill
}

% NULL
\newcommand{\NULL}{{\tt NULL}}

% Function definition
\newcommand{\Function}[4]{
	\vspace{0.3cm}
	\noindent
	\framebox[12.6cm][l]{{\bf function:} #1} \vspace{0.1cm}\newline
	{\bf Summary:\hspace{0.2cm}} #4\newline
	{\bf Declaration:}
		{\tt #2} {#1}({\tt #3});
	\index{#1}
%        \write 15 {\string\FuncEntry{#1}{#2}{#3}{#4}{\thepage}}
}

% Macro definition
\newcommand{\Macro}[4]{
	\vspace{0.3cm}
	\noindent
	\framebox[12.6cm][l]{{\bf macro:} {#1}} \vspace{0.1cm}\newline
	{\bf Summary:\hspace{0.2cm}} #4\newline
	{\bf Declaration:}
		{\tt #2} {#1}({\tt #3})
	\index{#1}
%	\write 14 {\string\MacroEntry{#1}{#2}{#3}{#4}{\thepage}}
}

% Function/Macro description (optional)
\newcommand{\Describe}[1]{

	\noindent{\bf Description:} #1
}

\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\asfix{\mbox{\sc AsFix}}

\title{\ATlib\ User Manual}
\author{\small H.A. de Jong, {\tt jong@wins.uva.nl} \\
		\small P.A. Olivier, {\tt olivierp@wins.uva.nl}}

\begin{document}
\maketitle

%----[ TABLE OF CONTENTS ]----
\tableofcontents

%----[ INTRODUCTION ]----
\section{Introduction}\label{intro}
This manual describes the functionality provided by the \ATlib. It is
intended to be a manual on how to use the \ATlib. Readers who are interested 
in the design details of the \ATlib, can find these in~\cite{BJO98}.

Section~\ref{usage} explains the basic steps that must be taken to
initialise and work with the \ATlib.

The level one interface described in Section~\ref{lvl1} offers a
set of operations on \aterms\ that is sufficiently powerful
for most users, yet is simple enough to comprehend in a relatively short
period of time.

Section~\ref{lvl2} describes the level two interface which is intented for
\aterm\ `power users', providing a more extensive set of datastructures and
functions.

The \ATlib{} comes with a number of utility programs. A description of
these programs can be found in Section~\ref{utils}.

%----[ USAGE ]----
\section{Using the \ATlib}\label{usage}
This section explains the basics of using the \ATlib. One design decision,
basing the \ATlib\ on maximally shared \ATerms, has some consequences that
readers should be familiar with before using the \ATlib.
Section~\ref{sharing} therefore addresses the notion of \emph{maximal
sharing} and its consequences on the use of \aterms.

The \ATlib\ has a built-in garbage collector. Section~\ref{gc} explains
what this garbage collector does and when it is invoked.

To use the \ATlib, it must first be initialised.  This ensures that the
garbage collector is activated and that all necessary internal structures
are set up. Section~\ref{init} demonstrates initialisation of the \ATlib\
and shows all possible commandline options. These alter the behaviour of the
\ATlib.

The garbage collector detects references to \aterms\ that are on the stack
and in any of the registers.  As it is also possible to have global
references to \aterms\ which the garbage collector cannot detect, it is the
user's responsibility to protect these references from premature erasure.
Section~\ref{prot} explains how to protect global \aterm\ variables and
arrays of \aterms.

The \ATlib\ is capable of storing \aterms\ in a compact, portable binary
notation.  Section~\ref{baf} describes this binary \aterm\ format.

%----[ SHARING ]---
\subsection{Maximal sharing}\label{sharing}
Although explaining the design details of the \ATlib\ is beyond the scope
of this manual, it is important that users realise that the \ATlib\ is
implemented using maximally shared \ATerms. This means that before a new
\ATerm\ is created, a lookup is done to see if that term already exists. If
so, that term is resued and no new term is created, resulting in maximally
shared terms. This has the advantage that equality of terms can be
expressed as being physically the same term, i.e. both terms must have the
same memory address. It also means that, as terms can be shared without the
user knowing it, they can not be modified without creating unwanted side
effects. Thus, users should not tamper with \ATerms. Rather, they should
use the functionality provided in the level one and level two interfaces.

%----[ GARBAGE COLLECTOR]-
\subsection{Garbage collector}\label{gc}
The \ATlib\ uses garbage collection to find and delete unused \ATerms. This
relieves users of the burden of explicitly allocating and freeing every
\ATerm\ used in an application. Each time a new \ATerm\ is allocated the
garbage collector decides whether time has come to free resources claimed
by unsed \ATerms\ or whether there is still enough space to create the
requested term. Details on the design and implementation of this garbage
collection can be found in~\cite{BJO98}.

%----[ INITIALISING ATERM LIBRARY ]----
\subsection{Initialising the \ATlib}\label{init}
To initialise the \ATlib, a call to \ATinit\ must be made from \main,
passing the commandline arguments stored in {\tt argc} and {\tt argv}.
Also, the address of a locally created ATerm variable must be passed.  This
address is used by the garbage collector to determine the bottom of the stack
to be inspected for \aterms.
The following code demonstrates a typical initialisation of the \ATlib.

\example{init.c}

\smallskip\noindent
The following commandline options can be passed to the \ATlib:
\medskip

\begin{tabular}{|l|l|}
 \hline
 {\tt -symboltable <nr\_symbols>} & Initial size of symboltable           \\
 {\tt -termtable <table\_class>}  & Start with termtable of
                                    $2^\textrm{table\_class}$ entries     \\
 {\tt -hashinfo} & write hashtable statistics to {\tt hashing.stats}      \\
				 & after execution \\
 {\tt -print-gc-time} & print timing information about garbage collector  \\
					  & to {\tt stderr} after execution \\
 {\tt -print-gc-info} & print verbose information about garbage collector \\
					  & to {\tt stderr} after execution \\
 {\tt -silent} & Do not print status and version information
 \\
 \hline
\end{tabular}

%----[ PROTECTING ATERMS]----
\subsection{Protecting global \aterms\ and arrays of \aterms}\label{prot}
During a garbage collect, the \ATlib\ searches the stack and registers for
\aterms. Therefore it finds all \aterms\ which were created locally in a
function (\emph{automatic} variables). All \aterm\ variables which were
\emph{not} created locally, must be protected by a call to \ATprotect. For
entire arrays of \aterms, \ATprotectArray\ should be used. Note that not
the \aterm\ variable itself, but its address is passed to \ATprotect. 
Users of the level two interface who create a function application by
building the function symbol (\Symbol) can also keep global references to
them. These references should be protected through a call to {\tt
ATprotect\Symbol}.

The following code demonstrates the protection of a global \aterm\ and a
global array of \aterms.

\example{prot.c}

\subsection{Unprotecting protected \aterms}\label{unprot}
When the lifetime of an \aterm\ that was protected as described in
Section~\ref{prot} has expired, it should be unprotected to free any
internal resources it holds. Note that these resources are not released
immediately. Instead, they are no longer marked as protected to the garbage
collector and as such may be freed at the next garbage collection. For each
{\tt ATprotect} function, there is a matching {\tt ATunprotect} function.

%----[ BINARY ATERM FORMAT ]----
\subsection{Binary \aterm\ Format ({\sc baf})}\label{baf}
In addition to being able to parse terms in textual format and write
textual representations of \aterms, the \ATlib\ is also equipped to store
and restore \ATerms\ in a compact, portable binary representation. This
representation is called {\sc baf} which stands for ``Binary \ATerm\
Format''.

This format can be used to write a binary version of an \ATerm\ to file,
which can later be restored in a much more efficient way than would be
possible had the \ATerm's textual counterpart been used. This is due to the
fact that textual representations have to be (re-)parsed each time they are
read from file, whereas {\sc baf} directly describes how to rebuild the
internal representation of an \ATerm, thus skipping the parsing phase.
Also, the internal sharing within an \ATerm\ is exploited when writing its
{\sc baf}-representation, making it take up much less space than its
textual representation would have needed.

Users of the \ATlib\ are encouraged to use {\sc baf} versions when saving
\aterms\ to file.  {\sc baf} was designed to be platform independent, which
facilitates the exchange of \ATerms. The \ATlib\ comes with a utility that
is able to convert an \ATerm's textual representation into its {\sc baf}
counterpart and vice versa (see Section~\ref{util-baffle}). This conversion
makes it possible to always work with {\sc baf} representations, while
still being able to look at the textual representation any time an error is
suspected. It also allows conversion of textual \ATerms\ written by
programs unable to write {\sc baf} which is especially convenient when
these \ATerms\ are bulky.

Although the \ATlib\ does not put any constraints on the names of \aterm-files,
users are encouraged to use the extension {\tt .baf} for {\sc baf} files.
This will avoid confusion between textual representations and binary ones.
Textual representations could use the extension {\tt .trm}.

%--------------------[ LEVEL ONE INTERFACE ]--------------------

\section{Level One Interface}\label{lvl1}
This section explains in detail the types and functions that are defined in
the level one interface. These functions are declared in {\tt aterm1.h}.
Section~\ref{types1} reveals the types of \aterms\ that are used in the
\ATlib, as well as the extension to the standard {\tt C}-types introduced
in the level one interface. To avoid confusion between {\sc baf} and the
\aterm\ type \emph{blob}, Section~\ref{blob-vs-baf} is dedicated to explain
the difference between these two notions. Finally, Section~\ref{func1}
describes all the functions that are available in the level one interface.

\subsection{Level One Types}\label{types1}
The following {\tt C}-defines are used to represent the different \aterm\
types:
\begin{small}
\begin{itemize}
	\item {\tt AT\_FREE}: An \aterm\ that is marked \emph{free} will be
	reused when needed. This is not a type users will want to create
	themselves, but it can be used to detect an \aterm\ that has been freed
	by the garbage collector.
	\item {\tt AT\_APPL}:        An \aterm\ of type: function application;
	\item {\tt AT\_INT}:         An \aterm\ of type: integer;
	\item {\tt AT\_REAL}:        An \aterm\ of type: real;
	\item {\tt AT\_LIST}:        An \aterm\ of type: list;
	\item {\tt AT\_PLACEHOLDER}: An \aterm\ of type: placeholder;
	\item {\tt AT\_BLOB}:        An \aterm\ of type: binary large object;
\end{itemize}
\end{small}

The following {\tt C}-types are defined in the level one interface:
\begin{small}
\begin{itemize}
	\item {\tt ATbool}: a boolean value, either \ATtrue\ or \ATfalse;
	\item {\tt ATerm}: an annotated term.
\end{itemize}
\end{small}

\subsection{A note on `blobs' and {\sc baf}}\label{blob-vs-baf}
Please note that although the word \emph{binary} is used in the
abbreviations of both ``blob'' and {\sc baf}, these are two very different
notions.  A \emph{blob} represents an \aterm\ that holds binary data, with
no specific meaning to the \ATlib. This notion can be used as a means of
escape in case you find that you need a type of \aterm\ that is not on the
list above.  The notion of {\sc baf} is explained in Section~\ref{baf} and
refers to a specific format used for reading and writing \aterms.  Thus an
\aterm\ of type {\tt AT\_BLOB} can be saved in {\sc baf}. It could also be
written in its textual representation, although this does not guarantee
that the blob will be readable, after all it represents binary data.

\subsection{Level One Functionality}\label{func1}
In this section, all functions and macros ({\tt \#define}'s in {\tt C}) are
listed. Although all macros could have been implemented as a function as
well, the macros listed here were chosen to be macros instead of functions
for efficiency reasons.

\Function{\tt ATmake}{\ATerm}{\tt const char *pattern, ...}
{Create an \ATerm from a string pattern and a variable number of arguments}
\Describe{
	Creates an \aterm\ given a pattern and corresponding values.
	The following table shows which patterns can be used, and which type
	of arguments should be passed if such a pattern is used.

	\smallskip
	\begin{small}
	\begin{tabular}{|l|l|l|}
	\hline
	Type & Pattern & Argument \\
	\hline
	Application & {\tt appl}        & {\tt char *pattern}, arguments \\
	Blob        & {\tt blob}        & {\tt int length}, {\tt void *data}\\
	Integer     & {\tt int}         & {\tt int value}\\
	List        & {\tt list}        & {\tt ATerm} \\
	Placeholder & {\tt placeholder} & {\tt char *type} \\
	Real        & {\tt real}        & {\tt double value}\\
	String      & {\tt str}         & {\tt char *pattern}, arguments \\
	Term        & {\tt term}        & {\tt ATerm} \\
	\hline
	\end{tabular}
	\end{small}

	\medskip\noindent
	Types {\tt <appl>} and {\tt <str>} should contain a pattern consisting
	of the function symbol to be used and the types of the arguments.  It
	must be followed by exactly the number of arguments that are used in the
	pattern. Also, the types of the arguments must match the respective
	types used in the pattern. Both {\tt <appl>} and {\tt <str>} create
	function applications. The difference is that {\tt <appl>} creates one
	with an \emph{unquoted} function symbol, whereas {\tt <str>} yields a
	quoted version.

	\smallskip\noindent
	Here are some examples of {\tt ATmake}:

	\example{make.c}
}

\Function{\tt ATvmake}{\tt \ATerm}{\tt const char *pattern, va\_list args}
{Create an \ATerm\ from a string pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{\tt ATmakeTerm}{\tt \ATerm}{\tt \ATerm\ pat, ...}
{Create an \ATerm\ from an \ATerm\ pattern and a variable number of
arguments}
\Describe{See {\tt ATmake}.}

\Function{\tt ATvmakeTerm}{\tt \ATerm}{\tt \ATerm\ pat, va\_list args}
{Create an \ATerm\ from an \ATerm\ pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{\tt ATmatch}{\tt ATbool}{\aterm\ t, const char *string}
{Match an \aterm\ against a pattern}
\Describe{
	Matches an \aterm\ against a pattern, attempting to fill the `holes'.
	If the \aterm\ matches the pattern, \ATtrue\ is returned and the
	variables will be filled according to the pattern, otherwise \ATfalse\
	is returned.

	The {\tt <list>} pattern can be used to match the tail of a list as
	well as a variable number of arguments in a function application. Thus
	the first few arguments may be matched explicitly while ``the rest'' of
	the arguments is directed to a list.


	\smallskip\noindent
	Here are a few examples of {\tt ATmatch}:

	\example{match.c}
}

\Function{\tt ATreadFromString}{\ATerm}{const char *string}
{Read an \aterm\ from string}
\Describe{
	This function parses an character string into an \aterm.
	A convenience macro {\tt ATparse} is included in {\tt aterm1.h}.
}

\Function{\tt ATreadFromTextFile}{\ATerm}{FILE *file}
{Read an \aterm\ from text file}
\Describe{
	This function reads a text file and parses the contents into an \aterm.
}

\Function{\tt ATreadFromBinaryFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary file ({\sc baf})}
\Describe{
	This function reads a binary file and builds an \aterm.
}

\Function{\tt ATreadFromFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary or textfile}
\Describe{
	This function reads an \aterm\ from a file. A magic number detection is
	done to see if the file is in {\sc baf}. If so, the binary term will
	be read, otherwise the textual term will be parsed.
}

\Macro{\tt ATparse}{\ATerm}{const char *str}
{A convenience macro for {\tt ATreadFromString}}
\Describe{
	This macro is simply a shortcut to {\tt ATreadFromString(str)}.
}

\Macro{\tt ATgetType}{int}{\ATerm\ term}
{Return the type of {\tt term}}
\Describe{
	A macro that returns the type of an \aterm. Result is one of
	{\tt AT\_APPL}, {\tt AT\_INT}, {\tt AT\_REAL}, {\tt AT\_LIST},
	{\tt AT\_PLACEHOLDER}, or {\tt AT\_BLOB}.
}

\Macro{\tt ATisEqual}{int}{\ATerm\ t1, \ATerm\ t2}
{A macro that tests equality of \aterms\ {\tt t1} and {\tt t2}}
\Describe{
	As \ATerms\ are shared, testing equality can be done by comparing the
	addresses of {\tt t1} and {\tt t2}, which is exactly what this macro does.
}

\Function{\tt ATwriteToTextFile}{\tt ATbool}{\aterm\ t, FILE *f}
{Writes term {\tt t} to file {\tt f} in textual format}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in textual format.
	This term can later be read again by {\tt ATreadFromTextFile}.
}

\Function{\tt ATwriteToBinaryFile}{\tt ATbool}{\tt \aterm\ t, FILE *F}
{Writes term {\tt t} to file {\tt f} in Binary ATerm Format ({\sc baf})}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in {\sc baf}.
	This term can later be read again by {\tt ATreadFromBinaryFile}.
}

\Function{\tt ATwriteToString}{\tt char *}{\aterm\ t}
{Writes term {\tt t} to a string}
\Describe{
	Writes term {\tt t} to an internal string buffer. The beginning of this
	buffer is returned. Note that the contents of this buffer are volatile
	and may be overwritten by any call to the \ATlib.
}

\Function{\tt ATsetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label, \aterm\ anno}
{Annotate a term with a labeled annotation}
\Describe{
	Creates a version of {\tt t} that is annotated with annotation {\tt anno}
	which is labeled by {\tt label}.
}

\Function{\tt ATgetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Retrieves annotation of {\tt t} with label {\tt label}}
\Describe{
	This function can be used to retrieve a specific annotation of a term.
	If {\tt t} has no annotations, or no annotation labeled with {\tt label}
	exists, \NULL\ is returned. Otherwise the annotation is returned.
}

\Function{\tt ATremoveAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Remove a specific annotation from a term}
\Describe{
	This function returns a version of {\tt t} which has its annotation with
	label {\tt label} removed. If {\tt t} has no annotations, or no annotation
	labeled with {\tt label} exists, {\tt t} itself is returned.
}

\Function{\tt ATinit}{\tt void}
{\tt int argc, char *argv[], \aterm\ *bottomOfStack}
{Initialise the \ATlib. See Section~\ref{init}}

\Function{\tt ATprintf}{\tt int}{\tt const char *format, ...}
{\ATerm\ version of {\tt printf}}
\Describe{See ATvfprintf}

\Function{\tt ATfprintf}{\tt int}{\tt FILE *stream, const char *format, ...}
{\ATerm\ version of {\tt fprintf}}
\Describe{See ATvfprintf}

\Function{\tt ATvfprintf}{\tt int}
{\tt FILE *stream, const char *format, va\_list args}
{\ATerm\ version of {\tt vfprintf}}
\Describe{
	The functions {\tt ATprintf}, {\tt ATfprintf} and {\tt ATvfprintf}
	are used for formatted output to file. The conversion specifiers
	{\tt c, d, i, o, u, x, X, e, E, f, g, G, p, s} behave as can be
	expected from {\tt (f)printf}. In addition the conversion specifiers
	{\tt l, n, t} and {\tt y} are supported:

	\begin{small}
	\begin{center}
	\begin{tabular}{|c|l|}
	\hline
	Conversion specifier & Action \\
	\hline
	{\tt l} & print an \aterm-list \\
	{\tt n} & print information about an \aterm\ node \\
	{\tt t} & print an \aterm \\
	{\tt y} & print the symbol of an \aterm-application \\
	\hline
	\end{tabular}
	\end{center}
	\end{small}
}
		
\Function{\tt ATsetErrorHandler}{\tt void}
{\tt (void (*handler)(const char *, va\_list))}
{Specify an errorhandler for the \ATlib.}
\Describe{
	This function can be used to set up an errorhandler for the \ATlib.
	This handler will be called when an errormessage is sent to {\tt ATerror}.
	If no handler is set, the message is printed to {\tt stderr} through
	{\tt ATfprintf} and the \ATlib\ then calls {\tt abort()}. 
}

\Function{\tt ATerror}{\tt void}{\tt (const char *format, ...)}
{Dump an errormessage and abort the \ATlib}
\Describe{
	If an errorhandler has been installed through a call to
	{\tt ATsetErrorHandler}, this handler will be called. Otherwise
	{\tt ATerror} prints a formatted message to {\tt stderr}, through
	{\tt ATvfprintf} (q.v.) followed by a call to {\tt abort}.
}

\Function{\tt ATprotect}{\tt void}{\aterm\ *atp}{Protect an \aterm}
\Describe{
	Protects an \aterm\ from being freed at garbage collection. See
	Section~\ref{prot}.
}

\Function{\tt ATunprotect}{\tt void}{\aterm\ *atp}{Unprotect an \aterm}
\label{at-unprot}
\Describe{
	Releases protection of an \aterm\ which has previously been protected
	through a call to {\tt ATprotect}.
}

\Function{\tt ATprotectArray}{void}{\aterm\ *start, int size)}
{Protect an array of \ATerms}
\label{at-unprot-arr}
\Describe{
	Protects an entire array of {\tt size} \aterms\ starting at {\tt start}.
}

\Function{\tt ATunprotectArray}{void}{\aterm\ *start)}
{Unprotect an array of \ATerms}
\Describe{
	Releases protection of the array of \aterms\ which starts at {\tt
	start}.
}

%--------------------[ LEVEL TWO INTERFACE ]--------------------

\section{Level Two Interface}\label{lvl2}
This section explains in detail the types and functions that are defined in
the level two interface. These functions are declared in {\tt aterm2.h}

\subsection{Level Two Types}\label{types2}
In addition to the C-types explained in Section~\ref{types1}, the level two
interface also uses the following types:
\begin{itemize}
	\item {\tt ATermInt}: an integer value;
	\item {\tt ATermReal}: a real value;
	\item {\tt ATermAppl}: a function application;
	\item {\tt ATermList}: a list;
	\item {\tt ATermPlaceholder}: a placeholder;
	\item {\tt ATermBlob}: a Binary Large OBject;
	\item {\tt ATermTable}: a hashtable of \aterms;
\end{itemize}

\subsection{Level Two Functionality}\label{func2}
Again, just as in section~\ref{func1}, all macros in this section could
have been implemented as functions, but where chosen to be in a macro for
efficiency reasons.

\subsubsection{ATermInt}
The type {\tt ATermInt} is the \ATerm\ representation of an integer. It
abides by the rules of the {\tt C}-type: {\tt int}.

\Function{\tt ATmakeInt}{\tt ATermInt}{\tt int value}
{Build an \aterm Int from an integer ({\tt int})}

\Macro{\tt ATgetInt}{\tt int}{\ATerm\ t}
{Get the integer value from an \aterm Int.}

\subsubsection{ATermReal}
The type {\tt ATermReal} is the \ATerm\ representation of a real. It
abides by the rules of the {\tt C}-type: {\tt double}.

\Function{\tt ATmakeReal}{\tt ATermReal}{double value}
{Build an \aterm Real from a real ({\tt double}).}

\Macro{\tt ATgetReal}{\tt double}{\tt \ATerm\ t}
{Macro to get the real value from an \aterm Real.}

\subsubsection{ATermAppl}
The type {\tt ATermAppl} denotes a function application. In order to build
a function application, first its function symbol (\Symbol) must be built.
This symbol holds the name of the function application, its arity (how many
arguments the function has) and whether the function name is quoted. Below
are some examples of function applications and the symbols needed to create
them.

\begin{small}
\begin{verbatim}
    true               - a zero arity, unquoted function application
                         sym = ATmakeSymbol("true", 0, ATfalse);

    "true"             - the same function application, but quoted
                         sym = ATmakeSymbol("true", 0, ATtrue);

    f(0)               - an unquoted function application of arity 1
                         sym = ATmakeSymbol("f", 1, ATfalse);

    "prod"(2, b, [])   - a quoted function application of arity 3
                         sym = ATmakeSymbol("prod", 3, ATtrue);
\end{verbatim}
\end{small}

\Function{\tt ATmake\Symbol}{\tt \Symbol}
{\tt char *name, int arity, ATbool quoted}
{Create a function symbol (\Symbol)}
\Describe{
	Creates a \Symbol, representing a function symbol with name {\tt name}
	and arity {\tt arity}. Quotedness is passed through the argument
	{\tt quoted}.
}

\Function{\tt ATprotect\Symbol}{void}{\Symbol\ sym}
{Protect a function symbol}
\label{at-unprot-sym}
\Describe{Just as \aterms\ which are not on the stack or in registers must
	be protected through a call to {\tt ATprotect}, so must \Symbol s be
	protected by calling {\tt ATprotect\Symbol}.
}

\Function{\tt ATunprotect\Symbol}{void}{\Symbol\ sym}
{Release a \Symbol's protection.}

\Macro{\tt ATgetName}{\tt char *}{\tt \Symbol\ sym}
{Return the name of a \Symbol}

\Macro{\tt ATgetArity}{\tt int}{\tt \Symbol sym}
{Return the arity of a \Symbol}

\Macro{\tt ATisQuoted}{\tt ATbool}{\tt \Symbol\ sym}
{Find out if a \Symbol\ is quoted or not}

\Function{\tt ATmakeAppl}{ATermAppl}{\Symbol\ sym, ...}
{Build an application from a \Symbol\ and a variable number of arguments.}
\Describe{
	The arity is taken from the first argument {\tt sym}, so the other
	arguments to {\tt ATmakeAppl} should be the arguments for the
	application. For arity $0\ldots 6$ the appropriate {\tt ATmakeAppl<N>} 
	can be used instead for better efficiency.
}

\Function{\tt ATmakeAppl0}{\tt ATermAppl}{\Symbol\ s}
{Make a function application with zero arguments}

\Function{\tt ATmakeAppl1}{\tt ATermAppl}{\Symbol\ s, \ATerm\ a0}
{Make a function application with one argument}

\Function{\tt ATmakeAppl2}{\tt ATermAppl}{\Symbol\ s, \ATerm\ a0, a1}
{Make a function application with two arguments}

\Function{\tt ATmakeAppl3}{\tt ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2}
{Make a function application with three arguments}

\Function{\tt ATmakeAppl4}{\tt ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2, a3}
{Make a function application with four arguments}

\Function{\tt ATmakeAppl5}{\tt ATermAppl}{\Symbol\ s,
	\ATerm\ a0, a1, a2, a3, a4}
{Make a function application with five arguments}

\Function{\tt ATmakeAppl6}{\tt ATermAppl}
{\Symbol\ s, \ATerm\ a0, a1, a2, a3, a4, a5}
{Make a function application with six arguments}
\Describe{
	These functions build an application of arity zero through 6, i.e.
	an application with $0\ldots 6$ arguments. Use these functions to
	build {\tt ATermAppl}s with small arity in favour of the generic
	{\tt ATmakeAppl} described above.
}

\Macro{\tt ATget\Symbol}{\Symbol}{\tt ATermAppl appl}
{Get the symbol of an application}

\Macro{\tt ATgetArgument}{\ATerm}{\tt ATermAppl appl, int nr}
{Get the {\tt nr}-th argument of an application}

\Function{\tt ATsetArgument}{ATermAppl}{ATermAppl appl, ATerm arg, int n}
{Set the {\tt nr}-th argument of an application to {\tt arg}}
\Describe{
	This function return a copy of {\tt appl} with argument {\tt n}
	replaced by {\tt arg}.
}

\Function{\tt ATgetArguments}{\tt ATermList}{ATermAppl appl}
{Get a list of arguments of an application}
\Describe{
	Return the arguments of {\tt appl} in {\tt ATermList} format.
	Note: traversing the arguments of {\tt appl} can be done more
	efficiently using the {\tt ATgetArgument} macro.
}

\Function{\tt ATmakeApplList}{\tt ATermAppl}{\Symbol\ sym, ATermList args}
{Build an application given a \Symbol\ and list of arguments}
\Describe{
	Build an application from {\tt sym} and the argumentlist {\tt args}.
	Note: unless the arguments are already in an {\tt ATermList}, it is
	probably more efficient to use the appropriate {\tt ATmakeAppl<N>}.
}

\Function{\tt ATmakeApplArray}{\tt ATermAppl}{\Symbol\ sym, ATerm args[]}
{Build an application given a \Symbol\ and array of arguments}

\subsubsection{ATermList}
\Function{\tt ATmakeList}{\tt ATermList}{int n, ...}
{Create an {\tt ATermList} of $n$ elements}
\Describe{
	This function can be used to build an {\tt ATermList} of $n$ elements.
	The elements should be passed as arguments $1\ldots n$.
}

\Macro{\tt ATmakeList0}{\tt ATermList}{}
{Macro defined to point to the empty list {\tt []}}

\Function{\tt ATmakeList1}{\tt ATermList}{\ATerm\ el0}
{Construct a list of one element}

\Function{\tt ATmakeList2}{\tt ATermList}{\ATerm\ el0, el1}
{Construct a list of two elements}

\Function{\tt ATmakeList3}{\tt ATermList}{\ATerm\ el0, el1, el2}
{Construct a list of three elements}

\Function{\tt ATmakeList4}{\tt ATermList}{\ATerm\ el0, el1, el2, el3}
{Construct a list of four elements}

\Function{\tt ATmakeList5}{\tt ATermList}{\ATerm\ el0, el1, el2, el3, el4}
{Construct a list of five elements}

\Function{\tt ATmakeList6}{\tt ATermList}{\ATerm\ el0, el1, el2, el3, el4, el5}
{Construct a list of six elements}
\Describe{
	These functions build an {\tt ATermList} of $1\ldots 6$ elements.
	Longer lists should be created using the generic {\tt ATmakeList}
	function described above.
}

\Macro{\tt ATgetLength}{\tt int}{\tt ATermList l}
{Macro to get the length of list {\tt l}}

\Macro{\tt ATgetFirst}{\ATerm}{\tt ATermList l}
{Macro to get the first element of list {\tt l}}

\Macro{\tt ATgetNext}{\tt ATermList}{\tt ATermList l}
{Macro to get the next part (the tail) of list {\tt l}}

\Macro{\tt ATisEmpty}{\tt ATbool}{\tt ATermList l}
{Macro to test if list {\tt l} is empty}

\Function{\tt ATgetPrefix}{\tt ATermList}{\tt ATermList list}
{Return all but the last element of {\tt list}}

\Function{\tt ATgetLast}{\ATerm}{\tt ATermList list}
{Return the last element of {\tt list}}

\Function{\tt ATgetSlice}{\tt ATermList}
{ATermList list, int start, int end}
{Get a portion (slice) of a list}
\Describe{
	Return the portion of {\tt list} that lies between {\tt start} and
	{\tt end}. Thus {\tt start} is included, {\tt end} is not.
}

\Function{\tt ATinsert}{\tt ATermlist}{\tt ATermList list, \ATerm\ el}
{Return {\tt list} with {\tt el} inserted.}
\Describe{
  The complexity of {\tt ATinsert} is $O(1)$. That is, the behaviour of
  {\tt ATinsert} does not degrade as the length of {\tt list} increases.
}

\Function{\tt ATinsertAt}{\tt ATermList}
{(ATermList list, \ATerm\ el, int index}
  {Return {\tt list} with {\tt el} inserted at position {\tt index}}

\Function{\tt ATappend}{\tt ATermList}{\tt ATermList list, ATerm el}
{Return {\tt list} with {\tt el} appended}
\Describe{
  Note that {\tt ATappend} is implemented in terms of {\tt ATinsert} by
  making a new list with {\tt el} as the first element and then {\tt
  ATinsert}ing all elements from {\tt list}. As such, the complexity of
  {\tt ATappend} is linear in the number of elements in {\tt list}.

  When {\tt ATappend} is needed inside a loop that traverses a list,
  behaviour of the loop will demonstrate quadratic complexity. To avoid
  this behaviour, the inner loop could use {\tt ATinsert} instead of {\tt
  ATappend} to make the new list. This will result in the target list being
  in reverse order. A single {\tt ATreverse} must therefore be performed,
  but this can be done once at the end of the loop bringing the behaviour
  down from quadratic to linear complexity, but at the cost of two {\tt
  ATinsert}s per element (one for each {\tt ATinsert} in the loop, and an
  implicit one for each element through the use of {\tt ATreverse}). 
  
  An even further optimisation could make use of a locally allocated
  buffer.  While traversing the list, all elements that would normally be
  {\tt ATappend}ed, are now placed in this buffer. Finally, the result is
  obtained by starting with an empty list and {\tt ATinsert}ing all
  elements from this buffer in reverse order. As the cost of allocating and
  freeing a local buffer is by no means marginal, this solution should
  probably only be applied when the loop appends more than just a few
  elements.
}

\Function{\tt ATconcat}{\tt ATermList}{\tt ATermList list1, ATermList list2}
{Return the concatenation of {\tt list1} and {\tt list2}}

\Function{\tt ATindexOf}{\tt int}{\tt ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list}
\Describe{
	Return the index where {\tt el} can be found in {\tt list}. Start
	looking at position {\tt start}. Returns {\tt -1} if {\tt el} is
	not in {\tt list}.
}

\Function{\tt ATlastIndexOf}{\tt int}
{\tt ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list (reverse)}
\Describe{
	Search backwards for {\tt el} in {\tt list}. Start searching at
	{\tt start}. Return the index of the first occurrence of {\tt l}
	encountered, or {\tt -1} when {\tt el} is not present before
	{\tt start}.
}

\Function{\tt ATelementAt}{\ATerm}{\tt ATermList list, int index)}
{Return a specific element of a list}
\Describe{
	Return the element at position {\tt index} in {\tt list}. Return
	\NULL\ when {\tt index} is not in {\tt list}.
}

\Function{\tt ATremoveElement}{\tt ATermList}{\tt ATermList list, \ATerm\ el}
{Return {\tt list} with one occurrence of {\tt el} removed}

\Function{\tt ATremoveAll}{\tt ATermList}{\tt ATermList list, \ATerm\ el}
{Return {\tt list} with all occurrences of {\tt el} removed}

\Function{\tt ATremoveElementAt}{\tt ATermList}
{\tt ATermList list, int index}
{Return {\tt list} with the element at {\tt index} removed}

\Function{\tt ATreplace}{\tt ATermList}{\tt ATermList list, \ATerm\ el, int idx}
{Return {\tt list} with the element at {\tt index} replaced by {\tt el}}

\Function{\tt ATreverse}{\tt ATermList}{\tt ATermList list)}
{Return {\tt list} with its elements in reversed order}

\Function{\tt ATfilter}{ATermList}
{ATermList list, ATbool (*predicate)(ATerm)}
{Filter entries from a list using a predicate}
\Describe{
 This function can be used to filter entries from a list that satisfy a
 given predicate. Each item in {\tt list} is judged through a call to
 {\tt predicate}. If {\tt predicate} returns {\tt ATtrue} the entry is
 added to a list, otherwise it is skipped. The function returns the list
 containing exactly those items that satisfy {\tt predicate}.
}

\subsubsection{ATermPlaceholder}
\Function{\tt ATmakePlaceholder}{\tt ATermPlaceholder}{\tt\ATerm\ type}
{Build an \aterm Placeholder of {\tt type}}

\Macro{\tt ATgetPlaceholder}{\ATerm}{\tt ATermPlaceholder ph}
{Get the type of an \aterm Placeholder}

\subsubsection{ATermBlob}
\Function{\tt ATmakeBlob}{\tt ATermBlob}{\tt int size, void *data)}
{Build a Binary Large OBject given {\tt size} (in bytes) and {\tt data}}
\Describe{
 This function can be used to create an \aterm\ of type blob, holding
 the data pointed to by {\tt data}. No copy of this data area is made, so
 the user should allocate this himself.

 Note: due to the internal representation of a blob, size cannot exceed
 $2^{24}$ in the current implementation. This limits the size of the data
 area to 16 Mb.
}

\Macro{\tt ATgetBlobData}{\tt void *}{\tt ATermBlob blob}
{Get the data section of {\tt blob}}

\Macro{\tt ATgetBloBSize}{\tt int}{\tt ATermBlob blob}
{Get the size (in bytes) of {\tt blob}}

\Function{\tt ATregisterBlobDestructor}{\tt void}
{\tt ATbool (*destructor)(ATermBlob)}
{Register a blob-destructor function}
\Describe{
 When a blob-destructor function has been registered, it will be called
 whenever the garbage collector deletes an ATermBlob. The destructor
 function can then handle the deletion of the data area of the blob. At
 most 16 blob destructor functions can be registered.
}

\Function{\tt ATunregisterBlobDestructor}{\tt void}
{\tt ATbool (*destructor)(ATermBlob)}
{Unregister a previously registered blob-destructor function}
\Describe{
	This removes the blob-destructor that has been previously installed
	through a call to {\tt ATregisterBlobDestructor}.
}

\subsection{Dictionaries}\label{dicts}
Dictionaries are datastructures which allow looking up a certain \ATerm\
given another \ATerm. The dictionary itself is also an \aterm\ and as such
is subject to the normal \ATlib\ rules of garbage collection. Each
dictionary consists of its own list of \ATerms.  For each lookup in the
dictionary, the list is traversed to see if the current element's key
matches the one that is being looked up. For a more efficient
\ATerm-to-\ATerm\ mapping, see Tables in section~\ref{tables}.

\Function{\tt ATdictCreate}{\tt \ATerm}{}{Create a new dictionary}

\Function{\tt ATdictGet}{\tt \ATerm}{\tt \ATerm\ dict, \ATerm\ key}
{Get the value belonging to a given key in a dictionary.}

\Function{\tt ATdictPut}{\tt \ATerm}
{\tt \ATerm\ dict, \ATerm\ key, \ATerm value}
{Add / update a (key, value)-pair in a dictionary}
\Describe{
 If {\tt key} does not already exist in the dictionary, this function adds
 the ({\tt key}, {\tt value})-pair to the dictionary. Otherwise, it updates
 the value to {\tt value}.
}

\Function{\tt ATdictRemove}{\tt \ATerm}{\tt \ATerm dict, \ATerm key}
{Remove the ({\tt key}, value)-pair from the dictionary}
\Describe{
	This function can be used to remove an entry from the dictionary.
	If the entry was actually in the dictionary, the modified dictionary is
	returned. If the entry was not in the dictionary in the first place,
	the (unmodified) dictionary itself is returned.
}

\subsection{Tables}\label{tables} The dictionaries described in
Section~\ref{dicts} are in essence nothing more than linked lists, which
makes them less suitable for large \aterm-to-\aterm\ mappings. To this end,
\ATerm\ tables were created. These are implemented as hashtables of
\aterms, with each hashbucket implemented as a dictionary.

\Function{\tt ATtableCreate}{ATermTable}{int initial\_size, int max\_load\_pct}
{Create an ATermTable}
\Describe{
 This function creates an ATermTable given an initial size and a maximum
 load percentage. Whenever this percentage is exceeded (which is detected
 when a new entry is added through {\tt ATtablePut}), the table is
 automatically expanded and all existing entries are rehashed into the new
 table.  If you know in advance approximately how many items will be in the
 table, you may set it up in such a way that no resizing (and thus no
 rehashing) is necessary. For example, if you expect about $1000$ items in
 the table, you can create it with its initial size set to $1333$ and a
 maximum load percentage of $75\%$. You are not required to do this, it
 merely saves a runtime expansion and rehashing of the table which
 increases efficiency.
}

\Function{\tt ATtableDestroy}{void}{ATermTable table}
{Destroy an ATermTable}
\Describe{
 Contrary to ATermDictionaries, ATermTables are themselves \emph{not}
 \ATerms. This means they are \emph{not} freed by the garbage collector
 when they are no longer referred to. Therefore, when the table is no
 longer needed, the user should release the resources allocated by the
 table by calling {\tt ATtableDestroy}. All references the table has to
 \aterms\ will then also be removed, so that those may be freed by the
 garbage collector (if no other references to them exist of course).
}

\Function{\tt ATtablePut}{void}{ATermTable table, ATerm key, ATerm value}
{Add / update a (key, value)-pair in a table}
\Describe{
 If {\tt key} does not already exist in the table, this function adds the
 ({\tt key}, {\tt value})-pair to the table. Otherwise, it updates the
 value to {\tt value}.
}

\Function{\tt ATtableGet}{ATerm}{ATermTable table, ATerm key}
{Get the value belonging to a given key in a table}


\Function{\tt ATtableRemove}{void}{ATermTable table, ATerm key}
{Remove the ({\tt key}, value)-pair from {\tt table}}

\Function{\tt ATtableKeys}{ATermList}{ATermTable table}
{Get an ATermList of all the keys in a table}
\Describe{
 This function can be useful if you need to iterate over all elements in a
 table. It returns an ATermList containing all the keys in the table. The
 corresponding values of each key you are interested in can then be
 retrieved through respective calls to {\tt ATtableGet}.
}

\section{Utilities}\label{utils}
This section describes the utilities that come with the \ATlib. These
utilities are automatically built when the \ATlib\ is compiled and
installed.

\subsection{\ATerm-conversion: {\tt baffle}}\label{util-baffle}
This utility can be used to convert {\sc baf} to text and vice versa.
It also offers the option of interpreting a {\sc baf}-file. This will show
the commands which are executed to (re-)build the \aterm. This option was
created to aid debugging {\sc baf}-files and is probably of little use to
the regular \ATlib\ user.
\smallskip\noindent
\begin{small}
\begin{verbatim}
Usage: baffle [-i <input>] [-o <output> | -c] [-v] [-rb | -rt] [-wb | -wt]
 
    -i <input>    - Read input from file <input>        (Default: stdin)
    -o <output>   - Write output to file <output>       (Default: stdout)
    -c            - Check validity of input-term
    -v            - Print version information
    -h            - Display help
    -ri           - Write interpretation of BAF-input
    -rb, -rt      - Choose between BAF and TEXT input   (Default: -rb)
    -wb, -wt      - Choose between BAF and TEXT output  (Default: -wb)
\end{verbatim}
\end{small}

\subsubsection{\tt trm2baf}
A small script called {\tt trm2baf} is included which can be used to
connect a process producing textual output and a proces which expects {\sc
baf} input. It just sets up {\tt baffle} with the appropriate switches and
redirects {\tt stdin} and {\tt stdout} accordingly.

\subsubsection{\tt baf2trm}
A small script called {\tt baf2trm} is included which can be used to
connect a process producing {\sc baf} output and a proces which expects
textual input. It just sets up {\tt baffle} with the appropriate switches
and redirects {\tt stdin} and {\tt stdout} accordingly.

\subsection{Calculating an \ATerm's size: {\tt termsize}}
\label{util-termsize}
This utility can be used to calculate two things:
\begin{itemize}
  \item coresize: the amount of memory a given \aterm\ needs;
  \item textsize: the amount of memory needed to hold a textual
  representation of an \aterm. 
\end{itemize}
The results are written to {\tt stdout}. As {\tt termsize} uses {\tt
ATreadFromFile}, it can calculate the size of both textual representations
of \aterms\ as well as {\sc baf} representations.

\smallskip\noindent Usage: {\tt termsize < }\emph{inputfile}.

%----[ INDEX ]----

\renewcommand{\indexname}
	{Index\addcontentsline{toc}{section}{\numberline{}Index}}
\printindex
 
%----[ BIBLIOGRAPHY ]----
\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
