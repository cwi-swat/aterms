%{{{ LaTeX configuration

% vim:ts=4:sw=4:tw=75
\documentclass[a4paper,twoside]{article}

%\usepackage{fullpage}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}
\usepackage{times}

\makeindex

\newcommand{\ATlib}{ATerm Library}
\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}

%% notion of Symbol was changed to AFun, which matches specification.
\newcommand{\Symbol}{AFun}

\newcommand{\ATtrue}{\mbox{\tt ATtrue}}
\newcommand{\ATfalse}{\mbox{\tt ATfalse}}
\newcommand{\main}{\mbox{\tt main}}
\newcommand{\ATinit}{\mbox{\tt ATinit}}
\newcommand{\ATprotect}{\mbox{\tt ATprotect}}
\newcommand{\ATprotectArray}{\mbox{\tt ATprotectArray}}

\newcommand{\toolbus}{\mbox{\tt ToolBus}}

% \example{init.c} will input file "examples/init.c" in verbatim mode.
\newcommand{\example}[1]{
	\noindent
	\hrulefill
	\begin{small}
	\verbatiminput{examples/#1}
	\end{small}
	\hrulefill
}

% NULL
\newcommand{\NULL}{{\tt NULL}}

% Function definition
\newcommand{\Function}[4]{
	\vspace{0.3cm}
	\pagebreak[3]
	\noindent
	\framebox[12.6cm][l]{
		\textbf{function:} \texttt{#1}
		\label{#1}
		\index{#1@\texttt{#1}}
	}\vspace{0.1cm}\newline
	\noindent\textbf{Summary:\hspace{0.2cm}} #4\newline
	\textbf{Declaration:}
		\texttt{#2} \texttt{#1}(\texttt{#3});
}

% Macro definition
\newcommand{\Macro}[4]{
	\vspace{0.3cm}
	\pagebreak[3]
	\noindent
	\framebox[12.6cm][l]{
		\textbf{macro:} \texttt{#1}
		\label{#1}
		\index{#1@\texttt{#1}}
	}\vspace{0.1cm}\newline
	\noindent\textbf{Summary:\hspace{0.2cm}} #4\newline
	\textbf{Declaration:}
		\texttt{#2} \texttt{#1}(\texttt{#3})
}

% Method definition
\newcommand{\Method}[4]{
	\vspace{0.3cm}
	\pagebreak[3]
	\noindent
	\framebox[12.6cm][l]{
		\textbf{method:} \texttt{#1}
		\label{#1}
		\index{#1@\texttt{#1}}
	}\vspace{0.1cm}\newline
	\noindent\textbf{Summary:\hspace{0.2cm}} #4\newline
	\textbf{Declaration:}
		\texttt{#2} \texttt{#1}(\texttt{#3});
}

% Throws exception (optional)
\newcommand{\Throws}[2]{

\noindent{\bf Throws:} {\tt #1} #2
}

% Function/Macro/Method description (optional)
\newcommand{\Describe}[1]{

	\noindent{\bf Description:} #1
}

\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\asfix{\mbox{\sc AsFix}}

%}}}
%{{{ Title page and table of contents

%----[ TITLE PAGE ]----

\title{\ATlib\ User Manual}
\author{Hayco de Jong \hspace{1cm} Pieter Olivier\\\\
{\small\sl Centrum voor Wiskunde en Informatica (CWI),}\\
{\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}\\\\
{\small\sl E-mail: \tt jong@cwi.nl - olivierp@cwi.nl}}

\date{}
\begin{document}
\maketitle

\begin{abstract}
This report is a manual describing the functionality provided by the
\ATlib, a high performance implementation of the \ATerm\ datatype using
maximal sharing and automatic garbage collection.
\end{abstract}

\tableofcontents
\newpage

%}}}
%{{{ Introduction

%----[ INTRODUCTION ]----
\section{Introduction}\label{intro}
This manual describes the functionality provided by the \ATlib. The library
is a high performance implementation of the \aterm\ datatype described
in~\cite{BJKO2000}. If your application satisfies the following list of
characteristics, the \ATlib\ can probably prove to be a valuable component.

\begin{itemize}
\item Maximal sharing of terms is required;
\item Automatic garbage collection is required;
\item There is no need for destructive update of terms (the \ATlib\ is
not suited to implement e.g. stacks).
\end{itemize}

Typical applications that benefit from using the \ATlib\ are those that
manipulate (abstract syntax) trees or terms, and those that are related to
the new {\sc Asf+Sdf} Meta-Environment \cite{BKMO97} or the new {\sc
Asf+Sdf} compiler~\cite{BOHK98}.

This manual is intended to be a comprehensive text on how to use the
\ATlib.  Readers who are interested in the design details of the \ATlib,
can find these in~\cite{BJKO2000}.

Section~\ref{usage} explains the basic steps that must be taken to
initialise and work with the \ATlib.

The level one interface described in Section~\ref{lvl1} offers a set of
operations on \aterms\ that is sufficiently powerful for most users, yet is
concise enough to be mastered in a relatively short period of time.

Section~\ref{lvl2} describes the level two interface which is intented for
experienced \aterm\ users, providing a more extensive set of datastructures
and functions.

The \ATlib{} comes with a number of utility programs. A description of
these programs can be found in Section~\ref{utils}.

%}}}
%{{{ Using the ATerm library

%----[ USAGE ]----
\section{Using the \ATlib}\label{usage}
This section explains the basics of using the \ATlib. One design decision,
basing the \ATlib\ on maximally shared \ATerms, has some consequences that
readers should be familiar with before using the \ATlib.
Section~\ref{sharing} therefore addresses the notion of \emph{maximal
sharing} and its consequences on the use of \aterms.

The \ATlib\ has a built-in garbage collector. Section~\ref{gc} explains
what this garbage collector does and when it is invoked.

To use the \ATlib, it must first be initialised.  This ensures that the
garbage collector is activated and that all necessary internal structures
are set up. Section~\ref{init} demonstrates initialisation of the \ATlib\
and shows all possible commandline options. These alter the behaviour of the
\ATlib.

The garbage collector detects references to \aterms\ that are on the stack
and in any of the registers.  As it is also possible to have global
references to \aterms\ which the garbage collector cannot detect, it is the
user's responsibility to protect these references from premature erasure.
Section~\ref{prot} explains how to protect global \aterm\ variables and
arrays of \aterms.

The \ATlib\ is capable of storing \aterms\ in a compact, portable binary
notation.  Section~\ref{baf} describes this binary \aterm\ format.

%----[ SHARING ]---
\subsection{Maximal sharing}\label{sharing}
Although explaining the design details of the \ATlib\ is beyond the scope
of this manual, it is important that users realise that the \ATlib\ is
implemented using maximally shared \ATerms. This means that before a new
\ATerm\ is created, a lookup is done to see if that term already exists. If
so, that term is reused and no new term is created, resulting in maximally
shared terms. This has the advantage that equality of terms can be
expressed as being physically the same term, i.e., both terms must have the
same memory address. It also means that, as terms can be shared without the
user knowing it, they cannot be modified without creating unwanted side
effects. Thus, users should not tamper with \ATerms. Rather, they should
use the functionality provided in the level one and level two interfaces.

%----[ GARBAGE COLLECTOR]-
\subsection{Garbage collector}\label{gc}
The \ATlib\ uses garbage collection to find and delete unused \ATerms. This
relieves users of the burden of explicitly allocating and freeing every
\ATerm\ used in an application. Each time a new \ATerm\ is allocated the
garbage collector decides whether time has come to free resources claimed
by unused \ATerms\ or whether there still is enough space to create the
requested term. Details on the design and implementation of this garbage
collection can be found in~\cite{BJKO2000}.

%----[ INITIALISING ATERM LIBRARY ]----
\subsection{Initialising the \ATlib}\label{init}
To initialise the \ATlib, a call to \ATinit\ must be made from \main,
passing the commandline arguments stored in {\tt argc} and {\tt argv}.
The address of a locally created ATerm variable must also be passed.  This
address is used by the garbage collector to determine the bottom of the stack
to be inspected for \aterms.
The following code demonstrates a typical initialisation of the \ATlib.

\example{init.c}

\smallskip\noindent
The following commandline options can be passed to the \ATlib:
\medskip

\begin{tabular}{|l|l|}
 \hline
 {\tt -at-symboltable <nr\_symbols>} & Initial size of symboltable           \\
 {\tt -at-termtable <table\_class>}  & Start with termtable of
                                    $2^\textrm{table\_class}$ entries     \\
 {\tt -at-hashinfo} & write hashtable statistics to {\tt hashing.stats}      \\
				 & after execution \\
 {\tt -at-print-gc-time} & print timing information about garbage collector  \\
					  & to {\tt stderr} after execution \\
 {\tt -at-print-gc-info} & print verbose information about garbage collector \\
					  & to {\tt stderr} after execution \\
 {\tt -at-silent} & Do not print status and version information
 \\
 \hline
\end{tabular}

%----[ PROTECTING ATERMS ]----
\subsection{Protecting global \aterms\ and arrays of \aterms}\label{prot}
During a garbage collect, the \ATlib\ searches the stack and registers for
\aterms. Therefore it finds all \aterms\ which were created locally in a
function (\emph{automatic} variables). All \aterm\ variables which were
\emph{not} created locally, must be protected by a call to \ATprotect. For
entire arrays of \aterms, \ATprotectArray\ should be used. Note that not
the \aterm\ variable itself, but its address is passed to \ATprotect.
Users of the level two interface who create a function application by
building the function symbol (\Symbol) can also keep global references to
these symbols. Such references should be protected through a call to {\tt
ATprotect\Symbol}.

The following code demonstrates the protection of a global \aterm\ and a
global array of \aterms.

\example{prot.c}

\subsection{Unprotecting protected \aterms}\label{unprot}
When the lifetime of an \aterm\ that was protected as described in
Section~\ref{prot} has expired, the \aterm\ should be unprotected to free any
internal resources it holds. Note that these resources are not released
immediately. Instead, they are no longer marked as protected to the garbage
collector and as such may be freed at the next garbage collection. For each
{\tt ATprotect} function, there is a matching {\tt ATunprotect} function.

%----[ BINARY ATERM FORMAT ]----
\subsection{Binary \aterm\ Format ({\sc baf})}\label{baf}
In addition to being able to parse terms in textual format and write
textual representations of \aterms, the \ATlib\ is also equipped to store
and restore \ATerms\ in a compact, portable binary representation. This
representation is called {\sc baf} which stands for ``Binary \ATerm\
Format''.

This format can be used to write a binary version of an \ATerm\ to file,
which can later be restored in a much more efficient way than would be
possible had the \ATerm's textual counterpart been used. This is due to the
fact that textual representations have to be (re-)parsed each time they are
read from file, whereas {\sc baf} directly describes how to rebuild the
internal representation of an \ATerm, thus skipping the parsing phase.
Moreover, the maximal sharing of \ATerms\ is exploited when writing {\sc
baf}-representations, making them take up much less space than their
textual representations would have needed.

Users of the \ATlib\ are encouraged to use {\sc baf} representations when
saving \aterms\ to file.  {\sc baf} was designed to be platform
independent, which facilitates the exchange of \ATerms. The \ATlib\ comes
with a utility that is able to convert an \ATerm's textual representation
into its {\sc baf} counterpart and vice versa (see
Section~\ref{util-baffle}). This conversion makes it possible to always
work with {\sc baf} representations, while still being able to look at the
textual representation any time an error is suspected. It also allows
conversion of textual \ATerms\ written by programs unable to write {\sc
baf} which is especially convenient when these \ATerms\ are bulky.

Although the \ATlib\ does not put any constraints on the names of \aterm-files,
users are encouraged to use the extension {\tt .baf} for {\sc baf} files.
This will avoid confusion between textual representations and binary ones.
Textual representations could use the extension {\tt .trm}.

\subsection{Shared Textual \aterm\ Format ({\sc taf})}\label{taf}
In addition to the binary aterm format there is also a textual aterm format
which supports maximal sharing but uses a much less complex algorithm than the
one used to encode and decode {\sc baf} files. This results in files that 
are somewhat larger than their baf counterparts, but are often (if the terms
contain redundancy) significantly smaller than their unparsed form.

{\sc taf} files always start with a '!' character to distinguish them
from aterm formats.
The format uses abbreviations to refer to previously written terms.
An abbreviation consists of a hash character ('\#') followed by a number
in encoded using the Base64 Alphabet (see RFC2045).

Each term whose unparsed representation would take up more bytes
than the textual representation of the next available abbreviation
is assigned such an abbreviation \emph{after} it has been written.
Subsequent occurences of this term are then written by emitting the
abbreviation instead of the term itself.

For example the term {\tt f(test,test)} is represented as {\tt !f(test,\#A)}
in {\sc taf}, whereas {\tt f(a,a)} is respresented as {\tt !f(a,a)} because
{\tt test} is longer than its abbreviation {\tt \#A}, but {\tt a} is not.

%}}}
%{{{ Level One Interface

%--------------------[ LEVEL ONE INTERFACE ]--------------------

\section{Level One Interface}\label{lvl1}
This section explains in detail the types and functions that are defined in
the level one interface. These functions are declared in {\tt aterm1.h}.
Section~\ref{types1} reveals the types of \aterms\ that are used in the
\ATlib, as well as the extension to the standard {\tt C}-types introduced
in the level one interface. To avoid confusion between {\sc baf} and the
\aterm\ type \emph{blob}, Section~\ref{blob-vs-baf} is dedicated to
explaining the difference between these two notions. Finally,
Section~\ref{func1} describes all the functions that are available in the
level one interface.

\subsection{Level One Types}\label{types1}
The following {\tt C}-defines are used to represent the different \aterm\
types:
\begin{small}
\begin{itemize}
	\item {\tt AT\_FREE}: An \aterm\ that is marked \emph{free} will be
	reused when needed. This is not a type users will want to create
	themselves, but it can be used to detect an \aterm\ that has been freed
	by the garbage collector.
	\item {\tt AT\_APPL}:        An \aterm\ of type: function application;
	\item {\tt AT\_INT}:         An \aterm\ of type: integer;
	\item {\tt AT\_REAL}:        An \aterm\ of type: real;
	\item {\tt AT\_LIST}:        An \aterm\ of type: list;
	\item {\tt AT\_PLACEHOLDER}: An \aterm\ of type: placeholder;
	\item {\tt AT\_BLOB}:        An \aterm\ of type: binary large object;
\end{itemize}
\end{small}

The following {\tt C}-types are defined in the level one interface:
\begin{small}
\begin{itemize}
	\item {\tt ATbool}: a boolean value, either \ATtrue\ or \ATfalse;
	\item {\tt ATerm}: an annotated term.
\end{itemize}
\end{small}

\subsection{A note on `blobs' and {\sc baf}}\label{blob-vs-baf}
Please note that although the word \emph{binary} is used in the
abbreviations of both ``blob'' and {\sc baf}, these are two very different
notions.  A \emph{blob} represents an \aterm\ that holds binary data, with
no specific meaning to the \ATlib. This notion can be used as a means of
escape in case you find that you need a type of \aterm\ that is not on the
list above.  The notion of {\sc baf} is explained in Section~\ref{baf} and
refers to a specific format used for reading and writing \aterms.  Thus an
\aterm\ of type {\tt AT\_BLOB} can be saved in {\sc baf}. It could also be
written in its textual representation, although this does not guarantee
that the blob will be readable, after all it represents binary data.

\subsection{Level One Functionality}\label{func1}
In this section, all functions and macros ({\tt \#define}'s in {\tt C}) are
listed. Although all macros could have been implemented as a function as
well, the macros listed here were chosen to be macros instead of functions
for efficiency reasons. To obtain access to the level one interface, your
application should {\tt \#include <aterm1.h>}.

\Function{ATmake}{\ATerm}{const char *pattern, ...}
{Create an \ATerm\ from a string pattern and a variable number of arguments}
\Describe{
	Creates an \aterm\ given a pattern and corresponding values.
	The following table shows which patterns can be used, and which type
	of arguments should be passed if such a pattern is used.

	\smallskip
	\begin{small}
	\begin{tabular}{|l|l|l|}
	\hline
	Type & Pattern & Argument \\
	\hline
	Application & {\tt <appl>}        & {\tt char *pattern}, arguments \\
	Blob        & {\tt <blob>}        & {\tt int length}, {\tt void *data}\\
	Integer     & {\tt <int>}         & {\tt int value}\\
	List        & {\tt <list>}        & {\tt ATerm} \\
	Placeholder & {\tt <placeholder>} & {\tt char *type} \\
	Real        & {\tt <real>}        & {\tt double value}\\
	String      & {\tt <str>}         & {\tt char *pattern}, arguments \\
	Term        & {\tt <term>}        & {\tt ATerm} \\
	\hline
	\end{tabular}
	\end{small}

	\medskip\noindent
	Types {\tt <appl>} and {\tt <str>} should contain a pattern consisting
	of the function symbol to be used and the types of the arguments.  This
	pattern must be followed by exactly the number of arguments that are
	used in the pattern. The types of the arguments must match the
	respective types used in the pattern. Both {\tt <appl>} and {\tt <str>}
	create function applications. The difference is that {\tt <appl>}
	creates one with an \emph{unquoted} function symbol, whereas {\tt
	<str>} yields a \emph{quoted} version.

	\smallskip\noindent
	Here are some examples of {\tt ATmake}:

	\example{make.c}
}

\Function{ATvmake}{\ATerm}{const char *pattern, va\_list args}
{Create an \ATerm\ from a string pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{ATmakeTerm}{\ATerm}{\ATerm\ pat, ...}
{Create an \ATerm\ from an \ATerm\ pattern and a variable number of
arguments}
\Describe{See {\tt ATmake}.}

\Function{ATvmakeTerm}{\ATerm}{\ATerm\ pat, va\_list args}
{Create an \ATerm\ from an \ATerm\ pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{ATmatch}{ATbool}{\aterm\ t, const char *pattern, ...}
{Match an \aterm\ against a pattern}
\Describe{
	Matches an \aterm\ against a pattern, attempting to fill the `holes'.
	If the \aterm\ matches the pattern, \ATtrue\ is returned and the
	variables will be filled according to the pattern, otherwise \ATfalse\
	is returned.

	The {\tt <list>} pattern can be used to match the tail of a list as
	well as a variable number of arguments in a function application. Thus
	the first few arguments may be matched explicitly while the tail of
	the arguments is directed to a list.


	\smallskip\noindent
	Here are a few examples of {\tt ATmatch}:

	\example{match.c}
}

\Function{ATreadFromString}{\ATerm}{const char *string}
{Read an \aterm\ from string}
\Describe{
	This function parses a character string into an \aterm.
	A convenience macro {\tt ATparse} is included in {\tt aterm1.h}.
}

\Function{ATreadFromBinaryString}{\ATerm}{const char *string, int size}
{Read a \aterm\ from a string in {\sc baf} format.}
\Describe{
	This function decodes a {\sc baf} character string into an \aterm.
}

\Function{ATreadFromSharedString}{\ATerm}{const char *string, int size}
{Read a \aterm\ from a string in {\sc taf} format.}
\Describe{
	This function decodes a {\sc taf} character string into an \aterm.
}

\Function{ATreadFromTextFile}{\ATerm}{FILE *file}
{Read an \aterm\ from text file}
\Describe{
	This function reads a text file and parses the contents into an \aterm.
}

\Function{ATreadFromBinaryFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary file ({\sc baf})}
\Describe{
	This function reads a binary file and builds an \aterm.
}

\Function{ATreadFromSharedTextFile}{\ATerm}{FILE *file}
{Read an \aterm\ from a shared text file ({\sc taf})}
\Describe{
        This function reads a shared text file and buils an \aterm. 
}

\Function{ATreadFromFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary or text file}
\Describe{
	This function reads an \aterm\ from a file. A test is performed
	to see if the file is in {\sc baf}, {\sc taf}, or plain text. 
}

\Function{ATreadFromNamedFile}{\ATerm}{char *filename}
{Read an \aterm\ from named binary or text file}
\Describe{
        This function reads an \aterm\ file {\tt filename}. A test is
        performed to see if the file is in {\sc baf}, {\sc taf}, or plain text.
        "-" is standard input's filename.
}

\Macro{ATparse}{\ATerm}{const char *str}
{A convenience macro for {\tt ATreadFromString}}
\Describe{
	This macro is simply a shortcut to {\tt ATreadFromString(str)}.
}



\Macro{ATgetType}{int}{\ATerm\ term}
{Return the type of {\tt term}}
\Describe{
	A macro that returns the type of an \aterm. Result is one of
	{\tt AT\_APPL}, {\tt AT\_INT}, {\tt AT\_REAL}, {\tt AT\_LIST},
	{\tt AT\_PLACEHOLDER}, or {\tt AT\_BLOB}.
}

\Macro{ATisEqual}{int}{\ATerm\ t1, \ATerm\ t2}
{A macro that tests equality of \aterms\ {\tt t1} and {\tt t2}}
\Describe{
	As \ATerms\ are created using \emph{maximal sharing} (see
	Section~\ref{sharing}), testing equality is performed in constant time
	by comparing the addresses of {\tt t1} and {\tt t2}. Note however
that {\tt ATisEqual} only returns {\tt ATtrue} when {\tt t1} and {\tt t2}
are completely equal, inclusive any annotations they might have!}

\Function{ATwriteToTextFile}{ATbool}{\aterm\ t, FILE *f}
{Writes term {\tt t} to file {\tt f} in textual format}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in textual format.
	This term can later be read again by {\tt ATreadFromTextFile}.
}

\Function{ATwriteToSharedTextFile}{long}{\aterm\ t, FILE *f}
{Writes term {\tt t} to file {\tt f} in shared Textual ATerm Format ({\sc taf})}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in {\sc taf},
	and returns the number of characters written.
	This term can later be read again by {\tt ATreadFromSharedTextFile}.
}

\Function{ATwriteToBinaryFile}{ATbool}{\aterm\ t, FILE *F}
{Writes term {\tt t} to file {\tt f} in Binary ATerm Format ({\sc baf})}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in {\sc baf}.
	This term can later be read again by {\tt ATreadFromBinaryFile}.
}

\Function{ATwriteToNamedTextFile}{\ATbool}{\aterm\ t, char *filename}
{Writes term {\tt t} to file named {\tt filename} in textual format}
\Describe{
	This function writes \aterm\ {\tt t} in textual representation
        to file  {\tt filename}.  "-" is standard output's filename.
}

\Function{ATwriteToNamedBinaryFile}{\ATbool}{\aterm\ t, char *filename}
{Writes term {\tt t} to file named {\tt filename} in Binary ATerm Format ({\sc baf})}
\Describe{
	This function writes \aterm\ {\tt t} in textual representation
        to file  {\tt filename}.  "-" is standard output's filename.
}

\Function{ATwriteToString}{char *}{\aterm\ t}
{Writes term {\tt t} to a string}
\Describe{
	Writes term {\tt t} to an internal string buffer. The start of this
	buffer is returned. Note that the contents of this buffer are volatile
	and may be overwritten by any call to the \ATlib.
}

\Function{ATwriteToSharedString}{char *}{\aterm\ t, int *len}
{Writes term {\tt t} to a shared text string in {\sc taf}}
\Describe{
	Writes term {\tt t} to an internal string buffer in {\sc taf}. 
        The start of this buffer is returned, and the length of the resulting string
        is stored in len. Note that the contents of this buffer are volatile
	and may be overwritten by any call to the \ATlib.
}

\Function{ATwriteToBinaryString}{char *}{\aterm\ t, int *len}
{Writes term {\tt t} to a shared text string in {\sc baf}}
\Describe{
	Writes term {\tt t} to an internal string buffer in {\sc baf}. 
        The start of this buffer is returned, and the length of the resulting string
        is stored in len. Note that the contents of this buffer are volatile
	and may be overwritten by any call to the \ATlib.
}

\Function{ATsetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label, \aterm\ anno}
{Annotate a term with a labeled annotation}
\Describe{
	Creates a version of {\tt t} that is annotated with annotation {\tt anno}
	which is labeled by {\tt label}.
}

\Function{ATgetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Retrieves annotation of {\tt t} with label {\tt label}}
\Describe{
	This function can be used to retrieve a specific annotation of a term.
	If {\tt t} has no annotations, or no annotation labeled with {\tt label}
	exists, \NULL\ is returned. Otherwise the annotation is returned.
}

\Function{ATremoveAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Remove a specific annotation from a term}
\Describe{
	This function returns a version of {\tt t} which has its annotation with
	label {\tt label} removed. If {\tt t} has no annotations, or no annotation
	labeled with {\tt label} exists, {\tt t} itself is returned.
}

\Function{ATinit}{void}
{\tt int argc, char *argv[], \aterm\ *bottomOfStack}
{Initialise the \ATlib.}
\Describe{See Section~\ref{init}.}

\Function{ATprintf}{int}{const char *format, ...}
{\ATerm\ version of {\tt printf}}
\Describe{See ATvfprintf.}

\Function{ATfprintf}{int}{FILE *stream, const char *format, ...}
{\ATerm\ version of {\tt fprintf}}
\Describe{See ATvfprintf.}

\Function{ATvfprintf}{int}{FILE *stream, const char *format, va\_list args}
{\ATerm\ version of {\tt vfprintf}}
\Describe{
	The functions {\tt ATprintf}, {\tt ATfprintf} and {\tt ATvfprintf}
	are used for formatted output to file. The conversion specifiers
	{\tt c, d, i, o, u, x, X, e, E, f, g, G, p, s} behave as can be
	expected from {\tt (f)printf}. In addition the conversion specifiers
	{\tt a, h, l, n} and {\tt t} are supported:

	\begin{small}
	\begin{center}
	\begin{tabular}{|c|l|}
	\hline
	Conversion specifier & Action \\
	\hline
	{\tt a} & print the symbol of an \aterm-application \\
	{\tt h} & print the MD5 checksum of an \aterm \\
	{\tt l} & print an \aterm-list \\
	{\tt n} & print information about an \aterm\ node \\
	{\tt t} & print an \aterm \\
	\hline
	\end{tabular}
	\end{center}
	\end{small}
}

\Function{ATsetWarningHandler}{void}
{\tt (void (*handler)(const char *, va\_list))}
{Specify a warninghandler for the \ATlib}
\Describe{
	Sets a warninghandler for the \ATlib. This handler will be called
	when an error message is sent to {\tt ATwarning}. }

\Function{ATwarning}{void}{(const char *format, ...)}
{Issue a warning message}
\Describe{
	If an errorhandler has been installed through a call to
	{\tt ATsetWarningHandler}, this handler will be called. Otherwise
	{\tt ATwarning} uses {\tt ATvfprintf} to print a formatted message
	to {\tt stderr} and returns.
}

\Function{ATsetErrorHandler}{void}
{\tt (void (*handler)(const char *, va\_list))}
{Specify an errorhandler for the \ATlib}
\Describe{
	Sets an errorhandler for the \ATlib.  This handler will be called
	when an error message is sent to {\tt ATerror}.
}

\Function{ATerror}{void}{(const char *format, ...)}
{Issue an errormessage and exit the \ATlib}
\Describe{
	If an errorhandler has been installed through a call to
	{\tt ATsetErrorHandler}, this handler will be called. Otherwise
	{\tt ATerror} uses {\tt ATvfprintf} to print a formatted message
	to {\tt stderr} and {\tt exit}s with errorcode 1.
}

\Function{ATsetAbortHandler}{void}
{\tt (void (*handler)(const char *, va\_list))}
{Specify an aborthandler for the \ATlib}
\Describe{
	Sets an aborthandler for the \ATlib.  This handler will be called
	when an error message is sent to {\tt ATabort}.
}

\Function{ATabort}{void}{(const char *format, ...)}
{Issue an errormessage and abort the \ATlib}
\Describe{
  If an aborthandler has been installed through a call to
  {\tt ATsetAbortHandler}, this handler will be called.  Otherwise
  {\tt ATabort} uses {\tt ATvfprintf} to print a formatted message
  to {\tt stderr} calls {\tt abort}.
}


\Function{ATprotect}{void}{\aterm\ *atp}{Protect an \aterm}
\Describe{
	Protects an \aterm\ from being freed at garbage collection. See
	Section~\ref{prot}.
}

\Function{ATunprotect}{void}{\aterm\ *atp}{Unprotect an \aterm}
\label{at-unprot}
\Describe{
	Releases protection of an \aterm\ which has previously been protected
	through a call to {\tt ATprotect}. See Section~\ref{unprot}.
}

\Function{ATprotectArray}{void}{\aterm\ *start, int size)}
{Protect an array of \ATerms}
\label{at-unprot-arr}
\Describe{
	Protects an entire array of {\tt size} \aterms\ starting at {\tt start}.
}

\Function{ATunprotectArray}{void}{\aterm\ *start)}
{Unprotect an array of \ATerms}
\Describe{
	Releases protection of the array of \aterms\ which starts at {\tt
	start}.
}

%--------------------[ LEVEL TWO INTERFACE ]--------------------

%}}}
%{{{ Level Two Interface

\section{Level Two Interface}\label{lvl2}
This section explains in detail the types and functions that are defined in
the level two interface. These functions are declared in {\tt aterm2.h}

\subsection{Level Two Types}\label{types2}
In addition to the C-types explained in Section~\ref{types1}, the level two
interface also uses the following types:
\begin{itemize}
	\item {\tt ATermInt}: an integer value;
	\item {\tt ATermReal}: a real value;
	\item {\tt ATermAppl}: a function application;
	\item {\tt ATermList}: a list;
	\item {\tt ATermPlaceholder}: a placeholder;
	\item {\tt ATermBlob}: a Binary Large OBject;
	\item {\tt ATermTable}: a hashtable of \aterms;
	\item {\tt ATermIndexedSet}: a set of \aterms where each
		element has a unique index.
\end{itemize}

\subsection{Level Two Functionality}\label{func2}
This section describes all functions and macros that are available in the
level two interface. To obtain access to this functionality you need to
{\tt \#include <aterm2.h>} instead of {\tt <aterm1.h>} in your application.

In Section~\ref{func1} we explained that the macros used in the level one
interface could just as well have been implemented as functions, but were
chosen to be implemented as macros for efficiency reasons. The same goes
for all macros described in this section.

\subsubsection{ATermInt}
The type {\tt ATermInt} is the \ATerm\ representation of an integer. It
abides by the rules of the {\tt C}-type: {\tt int}.

\Function{ATmakeInt}{ATermInt}{int value}
{Build an \aterm Int from an integer ({\tt int})}

\Macro{ATgetInt}{int}{ATermInt t}
{Get the integer value from an \aterm Int.}

\subsubsection{ATermReal}
The type {\tt ATermReal} is the \ATerm\ representation of a real. It
abides by the rules of the {\tt C}-type: {\tt double}.

\Function{ATmakeReal}{ATermReal}{double value}
{Build an \aterm Real from a real ({\tt double}).}

\Macro{ATgetReal}{double}{\ATerm\ t}
{Macro to get the real value from an \aterm Real.}

\subsubsection{ATermAppl}
The type {\tt ATermAppl} denotes a function application. In order to build
a function application, first its function symbol (\Symbol) must be built.
This symbol holds the name of the function application, its arity (how many
arguments the function has) and whether the function name is quoted. Below
are some examples of function applications and the symbols needed to create
them.

\begin{small}
\begin{verbatim}
    true               - a zero arity, unquoted function application
                         sym = ATmakeAFun("true", 0, ATfalse);

    "true"             - the same function application, but quoted
                         sym = ATmakeAFun("true", 0, ATtrue);

    f(0)               - an unquoted function application of arity 1
                         sym = ATmakeAFun("f", 1, ATfalse);

    "prod"(2, b, [])   - a quoted function application of arity 3
                         sym = ATmakeAFun("prod", 3, ATtrue);
\end{verbatim}
\end{small}

\Function{ATmake\Symbol}{\Symbol}
{\tt char *name, int arity, ATbool quoted}
{Create a function symbol (\Symbol)}
\Describe{
	Creates an \Symbol, representing a function symbol with name {\tt name}
	and arity {\tt arity}. Quotedness is passed through the {\tt quoted}
	argument.
}

\Function{ATprotect\Symbol}{void}{\Symbol\ sym}
{Protect a function symbol}
\label{at-unprot-sym}
\Describe{Just as \aterms\ which are not on the stack or in registers must
	be protected through a call to {\tt ATprotect}, so must \Symbol s be
	protected by calling {\tt ATprotect\Symbol}.
}

\Function{ATunprotect\Symbol}{void}{\Symbol\ sym}
{Release an \Symbol's protection.}

\Macro{ATgetName}{char *}{\Symbol\ sym}
{Return the name of an \Symbol}.

\Macro{ATgetArity}{int}{\Symbol\ sym}
{Return the arity (number of arguments) of a function symbol (\Symbol)}

\Macro{ATisQuoted}{ATbool}{\Symbol\ sym}
{Determine if a function symbol (\Symbol) is quoted or not}

\Function{ATmakeAppl}{ATermAppl}{\Symbol\ sym, ...}
{Build an application from an \Symbol\ and a variable number of arguments.}
\Describe{
	The arity is taken from the first argument {\tt sym}, the other
	arguments to {\tt ATmakeAppl} should be the arguments for the
	application. For arity $0\ldots 6$ the corresponding {\tt ATmakeAppl<N>}
	can be used instead for greater efficiency.  }

\Function{ATmakeAppl0}{ATermAppl}{\Symbol\ s}
{Make a function application with zero arguments}

\Function{ATmakeAppl1}{ATermAppl}{\Symbol\ s, \ATerm\ a0}
{Make a function application with one argument}

\Function{ATmakeAppl2}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1}
{Make a function application with two arguments}

\Function{ATmakeAppl3}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2}
{Make a function application with three arguments}

\Function{ATmakeAppl4}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2, a3}
{Make a function application with four arguments}

\Function{ATmakeAppl5}{ATermAppl}{\Symbol\ s,
	\ATerm\ a0, a1, a2, a3, a4}
{Make a function application with five arguments}

\Function{ATmakeAppl6}{ATermAppl}
{\Symbol\ s, \ATerm\ a0, a1, a2, a3, a4, a5}
{Make a function application with six arguments}
\Describe{
	These functions build an application of arity zero through six, i.e.
	an application with $0\ldots 6$ arguments. Use these functions to
	build {\tt ATermAppl}s with small arity in favour of the generic
	{\tt ATmakeAppl} described above.
}

\Macro{ATget\Symbol}{\Symbol}{ATermAppl appl}
{Get the function symbol (\Symbol) of an application}

\Macro{ATgetArgument}{\ATerm}{ATermAppl appl, int nr}
{Get the {\tt nr}-th argument of an application}

\Function{ATsetArgument}{ATermAppl}{ATermAppl appl, ATerm arg, int n}
{Set the {\tt nr}-th argument of an application to {\tt arg}}
\Describe{
	This function returns a copy of {\tt appl} with argument {\tt n}
	replaced by {\tt arg}.
}

\Function{ATgetArguments}{ATermList}{ATermAppl appl}
{Get a list of arguments of an application}
\Describe{
	Return the arguments of {\tt appl} in {\tt ATermList} format.
	Note: traversing the arguments of {\tt appl} can be done more
	efficiently using the {\tt ATgetArgument} macro.
}

\Function{ATmakeApplList}{ATermAppl}{\Symbol\ sym, ATermList args}
{Build an application given an \Symbol\ and a list of arguments}
\Describe{
	Build an application from {\tt sym} and the argument list {\tt args}.
	Note: unless the arguments are already in an {\tt ATermList}, it is
	probably more efficient to use the appropriate {\tt ATmakeAppl<N>}.
}

\Function{ATmakeApplArray}{ATermAppl}{\Symbol\ sym, ATerm args[]}
{Build an application given an \Symbol\ and an array of arguments}

\subsubsection{ATermList}
\Function{ATmakeList}{ATermList}{int n, ...}
{Create an {\tt ATermList} of $n$ elements}
\Describe{
	This function can be used to build an {\tt ATermList} of $n$ elements.
	The elements should be passed as arguments $1\ldots n$.
}

\Macro{ATmakeList0}{ATermList}{}
{Macro defined to point to the empty list {\tt []}}

\Function{ATmakeList1}{ATermList}{\ATerm\ el0}
{Construct a list of one element}

\Function{ATmakeList2}{ATermList}{\ATerm\ el0, el1}
{Construct a list of two elements}

\Function{ATmakeList3}{ATermList}{\ATerm\ el0, el1, el2}
{Construct a list of three elements}

\Function{ATmakeList4}{ATermList}{\ATerm\ el0, el1, el2, el3}
{Construct a list of four elements}

\Function{ATmakeList5}{ATermList}{\ATerm\ el0, el1, el2, el3, el4}
{Construct a list of five elements}

\Function{ATmakeList6}{ATermList}{\ATerm\ el0, el1, el2, el3, el4, el5}
{Construct a list of six elements}
\Describe{
	These functions build an {\tt ATermList} of $1\ldots 6$ elements.
	Longer lists should be created using the generic {\tt ATmakeList}
	function described above.
}

\Macro{ATgetLength}{int}{ATermList l}
{Macro to get the length of list {\tt l}}

\Macro{ATgetFirst}{\ATerm}{ATermList l}
{Macro to get the first element of list {\tt l}}

\Macro{ATgetNext}{ATermList}{ATermList l}
{Macro to get the next part (the tail) of list {\tt l}}

\Macro{ATisEmpty}{ATbool}{ATermList l}
{Macro to test if list {\tt l} is empty}

\Function{ATgetTail}{ATermList}{ATermList list, int start}
{Return the sublist from {\tt start} to the end of {\tt list}.}

\Function{ATreplaceTail}{ATermList}{ATermList list, ATermList newtail, 
int start}
{Replace the tail of {\tt list} from position {\tt start} with {\tt newtail}}

\Function{ATgetPrefix}{ATermList}{ATermList list}
{Return all but the last element of {\tt list}}

\Function{ATgetLast}{\ATerm}{ATermList list}
{Return the last element of {\tt list}}

\Function{ATgetSlice}{ATermList}
{ATermList list, int start, int end}
{Get a portion (slice) of a list}
\Describe{
	Return the portion of {\tt list} that lies between {\tt start} and
	{\tt end}. Thus {\tt start} is included, {\tt end} is not.
}

\Function{ATinsert}{ATermlist}{ATermList list, \ATerm\ el}
{Return {\tt list} with {\tt el} inserted.}
\Describe{
  The behaviour of {\tt ATinsert} is of constant complexity.  That is, the
  behaviour of {\tt ATinsert} does not degrade as the length of {\tt list}
  increases.  }

\Function{ATinsertAt}{ATermList}
{(ATermList list, \ATerm\ el, int index}
  {Return {\tt list} with {\tt el} inserted at position {\tt index}}

\Function{ATappend}{ATermList}{ATermList list, ATerm el}
{Return {\tt list} with {\tt el} appended to it}
\Describe{
  Note that {\tt ATappend} is implemented in terms of {\tt ATinsert} by
  making a new list with {\tt el} as the first element and then {\tt
  ATinsert}ing all elements from {\tt list}. As such, the complexity of
  {\tt ATappend} is linear in the number of elements in {\tt list}.

  When {\tt ATappend} is needed inside a loop that traverses a list (see
  {\tt parse\_list1} below), behaviour of the loop will demonstrate
  quadratic complexity.

  \example{app1.c}\smallskip

  To avoid this behaviour, the inner loop could use {\tt ATinsert} instead
  of {\tt ATappend} to make the new list. This will cause the resulting
  list to be in reverse order. A single {\tt ATreverse} must therefore be
  performed, but this can be done after the loop has terminated, bringing
  the behaviour down from quadratic to linear complexity, but at the cost
  of two {\tt ATinsert}s per element (one for each {\tt ATinsert} in the
  loop, and an implicit one for each element through the use of {\tt
  ATreverse}).  An example is shown here in the implementation of {\tt
  parse\_list2}.

  \example{app2.c}\smallskip

  An even further optimisation could make use of a locally allocated
  buffer.  While traversing the list, all elements that would normally be
  {\tt ATappend}ed, are now placed in this buffer. Finally, the result is
  obtained by starting with an empty list and {\tt ATinsert}ing all
  elements from this buffer in reverse order. As the cost of allocating and
  freeing a local buffer is by no means marginal, this solution should
  probably only be applied when the loop appends more than just a few
  elements. The following example shows such an implementation in {\tt
  parse\_list3}.

  \example{app3.c}
}

\Function{ATconcat}{ATermList}{ATermList list1, ATermList list2}
{Return the concatenation of {\tt list1} and {\tt list2}}

\Function{ATindexOf}{int}{ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list}
\Describe{
	Return the index where {\tt el} can be found in {\tt list}. Start
	looking at position {\tt start}. Returns {\tt -1} if {\tt el} is
	not in {\tt list}.
}

\Function{ATlastIndexOf}{int}
{\tt ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list (reverse)}
\Describe{
	Search backwards for {\tt el} in {\tt list}. Start searching at
	{\tt start}. Return the index of the first occurrence of {\tt l}
	encountered, or {\tt -1} when {\tt el} is not present before
	{\tt start}.
}

\Function{ATelementAt}{\ATerm}{ATermList list, int index)}
{Return a specific element of a list}
\Describe{
	Return the element at position {\tt index} in {\tt list}. Return
	\NULL\ when {\tt index} is not in {\tt list}.
}

\Function{ATremoveElement}{ATermList}{ATermList list, \ATerm\ el}
{Return {\tt list} with one occurrence of {\tt el} removed}

\Function{ATremoveAll}{ATermList}{ATermList list, \ATerm\ el}
{Return {\tt list} with all occurrences of {\tt el} removed}

\Function{ATremoveElementAt}{ATermList}
{\tt ATermList list, int index}
{Return {\tt list} with the element at {\tt index} removed}

\Function{ATreplace}{ATermList}{ATermList list, \ATerm\ el, int idx}
{Return {\tt list} with the element at {\tt index} replaced by {\tt el}}

\Function{ATreverse}{ATermList}{ATermList list)}
{Return {\tt list} with its elements in reversed order}

\Function{ATfilter}{ATermList}
{ATermList list, ATbool (*predicate)(ATerm)}
{Filter entries from a list using a predicate}
\Describe{
 This function can be used to filter entries that satisfy a given predicate
 from a list. Each item in {\tt list} is judged through a call to {\tt
 predicate}. If {\tt predicate} returns {\tt ATtrue} the entry is added to
 a list, otherwise it is skipped. The function returns the list containing
 exactly those items that satisfy {\tt predicate}.
}

\subsubsection{ATermPlaceholder}
A placeholder is a special subtype used to indicate a typed hole in an
\ATerm. This can be used to create a term of a specific type, even though
its actual contents are not filled in.

\Function{ATmakePlaceholder}{ATermPlaceholder}{\ATerm\ type}
{
  Build an \aterm Placeholder of a specific type. The type is taken from
  the {\tt type} parameter. See {\tt demo\_placeholder} below.
}

\Macro{ATgetPlaceholder}{\ATerm}{\ATerm Placeholder ph}
{Get the type of an \aterm Placeholder}

\example{plac.c}

\subsubsection{ATermBlob}
\Function{ATmakeBlob}{ATermBlob}{int size, void *data)}
{Build a Binary Large OBject given {\tt size} (in bytes) and {\tt data}}
\Describe{
 This function can be used to create an \aterm\ of type blob, holding
 the data pointed to by {\tt data}. No copy of this data area is made, so
 the user should allocate this himself.

 Note: due to the internal representation of a blob, size cannot exceed
 $2^{24}$ in the current implementation. This limits the size of the data
 area to 16 Mb.
}

\Macro{ATgetBlobData}{void *}{ATermBlob blob}
{Get the data section of {\tt blob}}

\Macro{ATgetBlobSize}{int}{ATermBlob blob}
{Get the size (in bytes) of {\tt blob}}

\Function{ATregisterBlobDestructor}{void}
{ATbool (*destructor)(ATermBlob)}
{Register a blob-destructor function}
\Describe{
 When a blob-destructor function has been registered, it will be called
 whenever the garbage collector deletes an ATermBlob. The destructor
 function can then handle the deletion of the data area of the blob. At
 most 16 blob destructor functions can be registered in the current
 implementation.
}

\Function{ATunregisterBlobDestructor}{void}
{ATbool (*destructor)(ATermBlob)}
{Unregister a previously registered blob-destructor function}
\Describe{
	This removes a blob-destructor that has been previously installed
	through a call to {\tt ATregisterBlobDestructor}.
}

\subsection{Dictionaries}\label{dicts}
Dictionaries are datastructures which allow looking up a certain \ATerm\
given another \ATerm. The dictionary itself is also an \aterm\ and as such
is subject to the \ATlib\ rules of garbage collection. Each dictionary
consists of its own list of \ATerms. For each lookup in the dictionary,
the list is traversed to see if the current element's key matches the one
being looked up. A lookup in a dictionary demonstrates behaviour linear in
the number of elements the dictionary contains. On average fifty percent of
the number of elements in the dictionary are examined before a match is
found (if the element is present at all). For a more efficient
\ATerm-to-\ATerm\ mapping, see Tables in section~\ref{tables}.

\Function{ATdictCreate}{\ATerm}{}{Create a new dictionary}

\Function{ATdictGet}{\ATerm}{\ATerm\ dict, \ATerm\ key}
{Get the value belonging to a given key in a dictionary.}

\Function{ATdictPut}{\ATerm}
{\ATerm\ dict, \ATerm\ key, \ATerm\ value}
{Add / update a (key, value)-pair in a dictionary}
\Describe{
 If {\tt key} does not already exist in the dictionary, this function adds
 the ({\tt key}, {\tt value})-pair to the dictionary. Otherwise, it updates
 the value to {\tt value}. The modified dictionary is returned.
}

\Function{ATdictRemove}{\ATerm}{\ATerm\ dict, \ATerm\ key}
{Remove the ({\tt key}, value)-pair from the dictionary}
\Describe{
	This function can be used to remove an entry from the dictionary.
	If the entry was actually in the dictionary, the modified dictionary is
	returned. If the entry was not in the dictionary in the first place,
	the (unmodified) dictionary itself is returned.
}

\subsection{Tables}\label{tables} The dictionaries described in
Section~\ref{dicts} are in essence nothing more than linked lists, which
makes them less suitable for large \aterm-to-\aterm\ mappings. To this end,
\ATerm\ tables were created. These are efficiently implemented using
a hash table
requiring approximately 16 bytes per stored entry, assuming that
the hash table is filled for 50\%.

\Function{ATtableCreate}{ATermTable}{int initial\_size, int max\_load\_pct}
{Create an ATermTable}
\Describe{
 This function creates an ATermTable given an initial size and a maximum
 load percentage. Whenever this percentage is exceeded (which is detected
 when a new entry is added using {\tt ATtablePut}), the table is
 automatically expanded and all existing entries are rehashed into the new
 table.  If you know in advance approximately how many items will be in the
 table, you may set it up in such a way that no resizing (and thus no
 rehashing) is necessary. For example, if you expect about $1000$ items in
 the table, you can create it with its initial size set to $1333$ and a
 maximum load percentage of $75\%$. You are not required to do this, it
 merely saves a runtime expansion and rehashing of the table which
 increases efficiency. 
}

\Function{ATtableDestroy}{void}{ATermTable table}
{Destroy an ATermTable}
\Describe{
 Contrary to ATermDictionaries, ATermTables are themselves \emph{not}
 \ATerms. This means they are \emph{not} freed by the garbage collector
 when they are no longer referred to. Therefore, when the table is no
 longer needed, the user should release the resources allocated by the
 table by calling {\tt ATtableDestroy}. All references the table has to
 \aterms\ will then also be removed, so that those may be freed by the
 garbage collector (if no other references to them exist of course).
}

\Function{ATtableReset}{void}{ATermTable table}
{Reset an ATermTable}
\Describe{This function resets an \ATerm table, without freeing the
memory it occupies. Its effect is the same as the subsequent execution
of a destroy and a create of a table, but as no memory is released
and obtained from the  C memeory management system this function is
generally cheaper. but if subsequent tables differ very much 
in size, the use of {\tt ATtableDestroy} and {\tt ATtableCreate}
may be prefered, because in such a way the sizes of the table
adapt automatically to the requirements of the application.
}

\Function{ATtablePut}{void}{ATermTable table, ATerm key, ATerm value}
{Add / update a (key, value)-pair in a table}
\Describe{
 If {\tt key} does not already exist in the table, this function adds the
 ({\tt key}, {\tt value})-pair to the table. Otherwise, it updates the
 value to {\tt value}.
}

\Function{ATtableGet}{ATerm}{ATermTable table, ATerm key}
{Get the value belonging to a given key in a table}


\Function{ATtableRemove}{void}{ATermTable table, ATerm key}
{Remove the (key, value)-pair from {\tt table}}

\Function{ATtableKeys}{ATermList}{ATermTable table}
{Get an ATermList of all the keys in a table}
\Describe{
 This function can be useful if you need to iterate over all elements in a
 table. It returns an ATermList containing all the keys in the table. The
 corresponding values of each key you are interested in can then be
 retrieved through respective calls to {\tt ATtableGet}.
}

\subsection{Indexed sets}\label{IndexedSets}
The data type {\tt ATermIndexedSet} provides a mapping or table from {\tt
ATerm}s to numbers, where it attempts to assign the numbers from 
one upwards subsequently to each entered term. If a number is assigned
to a term, the term will remain assigned until the term is removed from
the table. When assigning numbers to newly entered elements, numbers 
previously assigned to elements that have been removed are used first. 

This datatype can be used for different purposes. In the first place
one can make a mapping from {\tt ATerm}s to elements in any arbitrary
domain $D$ with it. By entering the {\tt ATerm}s in an {\tt
ATermIndexedSet} each {\tt ATerm} gets a subsequent number. These
numbers can be used as entries in a table to obtain the element of sort
$D$ belonging to the {\tt ATerm}.

Another type of application is the use as a set. Suppose that
a sequence of {\tt ATerm}s must be dealt with. Suppose that the sequence
can contain identical {\tt ATerm}s, and that each unique {\tt ATerm} needs
to be treated only once. Then each treated {\tt ATerm} can be entered
in the indexed set. For each to be investigated {\tt ATerm} one
inspection of the indexed set suffices to know whether this {\tt ATerm}
has already been considered. 
A particular instance of this kind of application is
the exploration of state spaces, where each state is represented by
an {\tt ATerm}.

The implementation {\tt ATermIndexedSet}s and {\tt ATermTable}s are 
strongly connected. The implementation is quite efficient both
in time and space, only requiring 12 bytes for each entry in
an indexed set, if the hash table, which forms it core, is half full. 

\Function{ATindexedSetCreate}{ATermIndexedSet}
{long initial\_size, int max\_load\_pct}
{Create a new {\tt ATermIndexedSet}}
\Describe{This function creates an {\tt ATermIndexedSet} with
approximately the size {\tt initial\_size}, where it guarantees that
the internal hash table, will be filled up to 
{\tt max\_load\_pct} percent. If
needed, the size of the hash table is dynamically extended to hold the
entries inserted into it. If 
extension of the hash table fails due to lack of memory. 
it is attempted to fill the hash table up to 100\%. 
All elements entered
into the indexed set are automatically protected. Note that for
each {\tt ATindexedSetCreate} an {\tt ATindexedSetDestroy} must be 
carried out to free memory, and to allow inserted elements to be released by
the automatic garbage system of the {\tt ATerm} library. Carrying out
a {\tt ATindexedSetReset} does not free the memory, but allows inserted
elements to be garbage collected.
}

\Function{ATindexedSetDestroy}{void}{ATermIndexedSet set}
{This function releases all memory occupied by the 
{\tt ATermIndexedSet}.
}

\Function{ATindexedSetReset}{void}{ATermIndexedSet set}
{Clear the hash table in the set.}
\Describe{
This function clears the hash table in the set, but does not release the memory.
Using {\tt ATindexedSetReset}
instead of {\tt ATindexedSetDestroy} is preferable when
indexed sets of approximately the same size are being used.
}

\Function{ATindexedSetPut}{long}{ATermIndexedSet set, ATerm elem, ATbool *new}
{Enter {\tt elem} into the set.}
\Describe{This functions enters {\tt elem} into the set. If {\tt elem} was
already in the set the previously assigned index of {\tt elem}
is returned, and {\tt new} is set to false. If {\tt elem} did not
yet occur in {\tt set} a new number is assigned, and {\tt new} is
set to true. This number can either be the number of an element
that has been removed, or, if such a number is not available, 
the lowest non used number is assigned to {\tt elem} and returned. 
The lowest number that is used is $0$.
}

\Function{ATindexedSetGetIndex}{long}{ATermIndexedSet set, ATerm elem}
{Find the index of {\tt elem} in {\tt set}}
\Describe{The index assigned to {\tt elem} is returned, except
when {\tt elem} is not in the set, in which case the return value
is a negative number.
}

\Function{ATindexedSetGetElem}{ATerm}{ATermIndexedSet set, long index}
{Retrieve the element at {\tt index} in {\tt set}}
\Describe{This function must be invoked with a valid index and
it returns the {\tt elem} assigned to this index. If it is invoked
with an invalid index, effects are not predictable.}

\Function{ATindexedSetRemove}{void}{ATermIndexedSet set, ATerm elem}
{Remove {\tt elem} from {\tt set}}
\Describe{The {\tt elem} is removed from the indexed set, and if a number
was assigned to {\tt elem},
it is freed to be reassigned to an element, that may be put into the set at
some later instance.
}

\Function{ATindexedSetElements}{ATermList}{ATermIndexedSet set}
{Retrieve all elements in {\tt set}}
\Describe{A list with all valid elements stored in the 
indexed set is returned. The list is ordered from element with index 0 onwards.
}


%}}}
%{{{ Utilities

\section{Utilities}\label{utils}
This section describes the utilities that come with the \ATlib. These
utilities are automatically built when the \ATlib\ is compiled and
installed.

\subsection{\ATerm-conversion: {\tt baffle}}\label{util-baffle}
This utility can be used to convert between the different \aterm\ formats:
{\tt text}, {\tt baf}, and {\tt taf}.

\smallskip\noindent
\begin{small}
\begin{verbatim}
Usage: baffle [-i <input>] [-o <output> | -c] [-v] [-rb | -rt | -rs] [-wb | -wt | -rs]

    -i <input>    - Read input from file <input>        (Default: stdin)
    -o <output>   - Write output to file <output>       (Default: stdout)
    -c            - Check validity of input-term
    -v            - Print version information
    -h            - Display help
    -rb, -rt, -rs - Choose between BAF, TEXT, and TAF input (Default: autodetect)
    -wb, -wt      - Choose between BAF, TEXT and TAF output (Default: -wb)
\end{verbatim}
\end{small}


Some small scripts are included which can be used to
connect a process producing one \aterm\ format to a process which expects 
another. These scripts just set up {\tt baffle} with the appropriate switches and
redirect {\tt stdin} and {\tt stdout} accordingly. These scripts are appropriately
called: {\tt trm2baf}, {\tt baf2trm}, {\tt trm2taf}, {\tt taf2trm}, {\tt baf2taf},
and {\tt taf2baf}.

\subsection{Calculating an \ATerm's size: {\tt termsize}}
\label{util-termsize}
This utility can be used to calculate three things:
\begin{itemize}
  \item core size: the amount of memory a given \aterm\ needs;
  \item text size: the amount of memory needed to hold a textual
  representation of an \aterm;
  \item tree depth: the maximum depth of a term.
\end{itemize}
The results are written to {\tt stdout}. As {\tt termsize} uses {\tt
ATreadFromFile}, it can calculate the size of both textual and {\sc baf}
representations of \aterms.

\smallskip\noindent Usage: {\tt termsize < }\emph{inputfile}.

\subsection{Calculating MD5 checksum of an \ATerm: {\tt atsum}}
\label{util-atsum}
This utility can be used to print the MD5 checksum of the
{\sc taf} representation of an \ATerm. The algorithm used is
the RSA Data Security, Inc. MD5 Message-Digest Algorithm (see RFC1321).

\smallskip\noindent Usage: {\tt atsum [\emph{inputfile}]}.

\subsection{Calculating differences between two \ATerms: {\tt atdiff}}
\label{util-atdiff}
This utility compares two terms and prints a template term that
covers the common parts containing {\tt <diff>} placeholders for
subterms that differed, and a list of their differing subterms.

\smallskip\noindent
\begin{small}
\begin{verbatim}
Usage: atdiff [<options>] <file1> <file2>
Options:
    --nodiffs | --diffs <diff-file>              (default: stdout)
    --notemplate | --template <template-file>    (default: stdout)
\end{verbatim}
\end{small}

%}}}
%{{{ Index

%----[ INDEX ]----

\renewcommand{\indexname}
	{Index\addcontentsline{toc}{section}{\numberline{}Index}}
\printindex

%}}}
%{{{ Bibliography

%----[ BIBLIOGRAPHY ]----
\bibliographystyle{alpha}
\bibliography{thesis}

%}}}

\appendix

%{{{ The ToolBus layer

\section{The ToolBus layer}

The \ATerm\ library also provides functionality needed to implement
\toolbus\ tools. This section describes this \toolbus\ layer in detail.

%{{{ Generation of tool interfaces

\subsection{Generation of tool interfaces}

The \ATerm\ library provides a program that takes a standard
\toolbus\ \emph{tifs} file, which is generated by the toolbus interpreter
when started with the {\tt -gentifs} option, and generates
a tool interface in C for use with the \ATerm\ library.

The generated interface consists of two files, a C source file
and a C header (include) file. In the header file a number of interface
functions is declared, one for each element in the input signature of the tool.
It is up to the writer of the tool to provide an implementation for
these functions. The generated C file contains a handler function
that analyzes incoming terms from the \toolbus, and delegates to the
appropriate interface function.

%}}}
%{{{ Example

\subsection{Example}

Suppose we take the following simple \toolbus\ script {\tt "test.tb"}:

\begin{verbatim}
  tool testing is { command = "./testing" }

  process TEST is
  let
    T : testing,
    R : str
  in
    execute(testing, T?) .
    snd-do(T, f1(42)) .
    snd-eval(T, f2("hello world!")) .
    rec-value(T, result(R?)) .
    printf("result: %s\n", R)
  endlet

  toolbus(TEST)
\end{verbatim}

Using the command:
\begin{verbatim}
   toolbus -gentifs test.tb
\end{verbatim}
we generate a file called {\tt "test.tifs"}. Using the command:
\begin{verbatim}
   tifstoc -tool testing test.tifs
\end{verbatim}
we generate the header file {\tt "testing.tif.h"} and the source
file {\tt "testing.tif.c"}.

{\tt "testing.tif.h"} looks like this:
\begin{verbatim}
  /**
   * This file is generated by tifstoc. Do not edit!
   * Generated from tifs for tool 'testing'
   * Headerfile generated at Thu Apr 22 11:37:36 1999
   */

  #ifndef _TESTING_H
  #define _TESTING_H

  #include <atb-tool.h>

  /* Prototypes for functions called from the event handler */
  void f1(int conn, int);
  ATerm f2(int conn, char *);
  void rec_terminate(int conn, ATerm);
  extern ATerm testing_handler(int conn, ATerm term);
  extern ATerm testing_checker(int conn, ATerm sigs);

  #endif
\end{verbatim}

Only the functions {\tt f1}, {\tt f2}, and {\tt rec\_terminate}
together with a simple {\tt main} function
have to be implemented to build a fully functional \toolbus\ tool.
The implementation of the functions {\tt testing\_handler} and
{\tt testing\_checker} has been generated in the file {\tt "testing.tif.c"},
which looks like this:

\begin{verbatim}
  /**
   * This file is generated by tifstoc. Do not edit!
   * Generated from tifs for tool 'testing'
   * Implementation generated at Thu Apr 22 11:37:36 1999
   */

  #include "testing.tif.h"

  #define NR_SIG_ENTRIES  3

  static char *signature[NR_SIG_ENTRIES] = {
    "rec-terminate(<testing>,<term>)",
    "rec-eval(<testing>,f2(<str>))",
    "rec-do(<testing>,f1(<int>))",
  };

  /* Event handler for tool 'testing' */
  ATerm testing_handler(int conn, ATerm term)
  {
    ATerm in, out;
    /* We need some temporary variables during matching */
    int i0;
    char *s0;
    ATerm t0;

    if(ATmatch(term, "rec-eval(f2(<str>))", &s0)) {
      return f2(conn, s0);
    }
    if(ATmatch(term, "rec-terminate(<term>)", &t0)) {
      rec_terminate(conn, t0);
      return NULL;
    }
    if(ATmatch(term, "rec-do(f1(<int>))", &i0)) {
      f1(conn, i0);
      return NULL;
    }
    if(ATmatch(term, "rec-do(signature(<term>,<term>))", &in, &out)) {
      ATerm result = testing_checker(conn, in);
      if(!ATmatch(result, "[]"))
        ATfprintf(stderr, "warning: not in input signature:\n\t%\n\tl\n", result);
      return NULL;
    }

    ATerror("tool testing cannot handle term %t", term);
    return NULL; /* Silence the compiler */
  }

  /* Check the signature of the tool 'testing' */
  ATerm testing_checker(int conn, ATerm siglist)
  {
    return ATBcheckSignature(siglist, signature, NR_SIG_ENTRIES);
  }
\end{verbatim}

This file contains an array of signature definitions ({\tt signature}),
the handler function ({\tt testing\_handler}), and the signature
checker ({\tt testing\_checker}). The only thing the handler does
is differentiating between the different possible input terms
coming from the \toolbus, and delegating the actual work to the
appropriate function.

As mentioned earlier, the only thing needed to implement the
actual tool, is the implementation of the three interface
functions {\tt f1}, {\tt f2}, and {\tt rec\_terminate}, and
the implementation of {\tt main} to get things going.
We will first take a look at the initialization stuff that
the {\tt main} function has to do:

\begin{verbatim}
  #include "testing.tif.h"

  int main(int argc, char *argv[])
  {
    ATerm bottomOfStack;

    ATBinit(argc, argv, &bottomOfStack);
    if(ATBconnect(NULL, NULL, -1, testing_handler) >= 0) {
      ATBeventloop();
    } else {
      fprintf(stderr, "Could not connect to the ToolBus, giving up!\n");
      return -1;
    }

    return 0;
  }
\end{verbatim}

The variable {\tt bottomOfStack} is needed by the \aterm\ library
to determine where to look for the stack. {\tt argc} and {\tt argv}
are passed unchanged to {\tt ATBinit}, so the \toolbus\ library can
look for default values for things like the \toolbus\ socket address
and the \toolbus\ host name.

The call to {\tt ATBconnect} connects to a running \toolbus, and
requires four arguments: a character
string representing the tool name, a character string representing
the host name of the \toolbus\ to connect to, the port number of the
\toolbus\ to connect to, and a handler function. Passing {\tt NULL},
{\tt NULL}, and {\tt -1} respectively as the tool name, the
host name, and the port number cause the defaults for these values
to be used instead.

When all goes well, the call to {\tt ATBeventloop} starts the main
\toolbus\ eventloop and the tool will be ready to receive requests
from the \toolbus.

Now we only need the implementation of the three interface functions:
\begin{verbatim}
  void f1(int conn, int value)
  {
    printf("f1 called: %d\n", value);
  }

  ATerm f2(int conn, char *value)
  {
    return ATmake("snd-value(result(<str>))", value);
  }

  void rec_terminate(int conn, ATerm arg)
  {
    exit(0);
  }
\end{verbatim}

Note that the {\tt conn} argument identifies the \toolbus\ connection,
making it possible to distinguish which \toolbus\ made the request
when connected to more than one \toolbus\ at the same time.

%}}}
%{{{ Functions in the \toolbus\ layer

\subsection{Functions in the \toolbus\ layer}

The \toolbus\ layer offers the following functions:

\Function{ATBinit}{int}{int argc, char *argv[], ATerm *stack\_bottom}
{Initialize the \toolbus\ layer and the underlying \aterm\ library
when needed.}
\Describe{The return value indicates whether or not the \toolbus\
host could be found. {\tt 0} indicates that all is well, and {\tt -1}
indicates an error, in which case {\tt errno} is set to indicate
which error.}

\Function{ATBconnect}{int}{char *toolname, char *host, int port, ATBhandler h}
{Connect to a running \toolbus.}
\Describe{When {\tt NULL} is passed as {\tt toolname} or {\tt host}, or
{\tt -1} is passed as {\tt port}, default values are taken from {\tt argv}
passed to {\tt ATBinit}. The return value indicates whether or not the
connection succeeded. {\tt -1} means that the connection failed and a
positive number or zero indicates a succesful connection attempt. In this
case this number is also the file descriptor of the socket connection
to the \toolbus.}

\Function{ATBdisconnect}{void}{int fd}
{Disconnect a from a \toolbus.}
\Describe{This function can be used to terminate a connection that
has been established earlier using {\tt ATBconnect}}

\Function{ATBeventloop}{int}{void}
{Start the tool event loop, reading and handling terms until
a connection is broken.}
\Describe{This function will not return unless something goes wrong!}

\Function{ATBwriteTerm}{int}{int fd, ATerm term}
{Send a term to the \toolbus.}
\Describe{A term is send using the \toolbus\ connection indicated by
{\tt fd}. This function is typically used to generate \toolbus\
events, for instance:

{\tt ATBwriteTerm(fd, ATparse("snd-event(some-event)"));}
When something goes wrong, {\tt -1} is returned, otherwise {\tt 0} is
returned.}

\subsection{Control flow without the {\tt ATBeventloop}}
In some situations, the {\tt ATBeventloop} function does not offer
the right flow of control for a specific application. In this case,
the following set of functions can be used to create custom control
flow patterns:

\Function{ATBpeekOne}{ATbool}{int fd}
{Check if there is input waiting on a \toolbus\ connection}
\Describe{If there is input waiting on the specified connection,
{\tt ATtrue} is returned. Otherwise, {\tt ATfalse} is returned.}

\Function{ATBpeekAny}{int}{}
{Check if there is input waiting on any \toolbus\ connection}
\Describe{If there is input waiting on one of the \toolbus\
connections, the appropriate file-descriptor is returned. Otherwise,
{\tt -1} is returned. This function provides for some `fairness' by
using a round-robin scheme in traversing the connections between
calls.}

\Function{ATBreadTerm}{ATerm}{int fd}
{Read a term from a \toolbus\ connection.}

\Function{ATBhandleOne}{int}{int fd}
{Read one term from a \toolbus\ connection, and call the
appropriate handler. {\tt -1} is returned when something goes wrong.}

\Function{ATBhandleAny}{int}{}
{Read a single term from any \toolbus\ connection and call
the appropriate handler. {\tt -1} is returned when something
goes wrong.}

\Function{ATBgetDescriptors}{int}{fd\_set *set}
{Gather all \toolbus\ connection file descriptor in a single
descriptor set. The return value indicates the maximum
value of any descriptor in the set.}

Note that the standard {\tt ATBeventloop} can be expressed using
the following code:
\begin{verbatim}
  int ATBeventloop(void)
  {
    int fd;
    while(ATtrue) {
      fd = ATBhandleAny();
      if(fd < 0)
        return -1;
    }
  }
\end{verbatim}

%}}}

%}}}
%{{{ The Java implementation

\section{Java implementation}

Besides the C implementaton discussed upto now, we also developed
a Java implementation of the ATerm datatype. We have tried to
keep the interfaces of the C implementation and the Java implementation
as close together as possible. Unfortunately, constraints imposed by
both languages prohibit the use of a single interface for both languages.
In this section we will discuss the Java interface, and highlight the
differences with the C interface where appropriate.

Most differences are introduced by the fact that Java is a much more
powerful language than C. Garbage collection for instance is a built-in
feature of the Java language, so no {\tt protect} and {\tt unprotect}
functions are needed in Java.

% {{{  Interfaces and Implementation

\subsection{Interfaces and Implementation}
The interface {\tt ATerm} defines functionality relevant for all ATerm
subtypes. Each of these ATerm subtypes has its own interface, describing
the additional functionality relevant for that particular subtype.

An interface {\tt ATermFactory} describes the various methods used to
create new ATerm objects. It is used to implement maximal sharing.

A complete description of these interfaces can be found in the file
{\tt java-api.ps} which is distributed with this manual.

The ATerm library distribution so far comes with a single implementation
of the ATerm interfaces. This implementation is a ``pure'' Java one,
but plans exist to experiment with an implementation using the Java
Native Interface (JNI) to build a layer of Java code on top of the
C implementation.

A very basic example that shows the creation of some ATerms and how
to read one from a stream is shown below.

\begin{verbatim}
import java.io.*;
import aterm.*;

public class Basic
{
  private ATermFactory factory;

  public static final void main(String[] args) throws IOException {
    Basic basic = new Basic(args);
  }

  public Basic(String[] args) throws IOException {
    factory = new aterm.pure.PureFactory();

    ATermInt i = factory.makeInt(42);
    System.out.println("i = " + i);

    AFun fun = factory.makeAFun("foo", 2, false);
    ATermAppl foo = factory.makeAppl(fun, i, i);
    System.out.println("foo = " + foo);

    ATerm t = factory.parse("this(is(a(term(0))))");
    System.out.println("t = " + t);

    try {
      ATerm input = factory.readFromFile(System.in);
      System.out.println("You typed a valid term: " + input);
    } catch (ParseError error) {
      System.out.println("Your input was not a valid term!");
    }
  }
}
\end{verbatim}

% }}}
%{{{ Class hierarchy

\subsection{Class hierarchy}

Because Java is an object oriented language, we have partitioned
the Java implementation in a number of classes. The resulting class
hierarchy is shown in Figure \ref{class-hierarchy}.

\begin{figure}[htb]
\centerline{\epsfig{scale=0.4, file=hierarchy.eps}}
\caption{\label{class-hierarchy}Simple ATerm class library}
\end{figure}

%}}}
% {{{ Connecting Java tools

\section{Connecting Java tools}

This section shows how to write a simple Java application and which
steps need to be taken to connect it to the ToolBus.

The example tool is a simple Java Application which pops up a GUI with
a button that can be pressed by the user. Further, it contains a method
{\tt msg} which can be called by the ToolBus. This method prints the
string that was passed and returns a count indicating the message number.

In order to get from the ToolBus script {\tt example.tb} to the generated
{\tt .java} files, we follow steps similar to the procedure to connect
a {\tt C} program to the ToolBus.

\begin{itemize}
  \item Generate Tool Interface file {\tt example.tifs}
    \begin{verbatim}
	~/tmp > toolbus -gentifs example.tb
	Tool interfaces written to `example.tifs'
	\end{verbatim}

  \item Generate Java code for tool {\tt example}
    \begin{verbatim}
	~/tmp > tifstojava -tool example -tifs example.tifs 
	generating file ExampleTif.java
	generating file ExampleTool.java
	generating file ExampleBridge.java
	\end{verbatim}
\end{itemize}


As you can see, three files are generated for our Example tool:
\begin{itemize}
  \item {\tt ExampleTif.java}
    the Java interface describing our Tool's functionality.
  \item {\tt ExampleTool.java}
    an \emph{abstract} implementation of {\tt ExampleTif.java}
    containing just enough code to check the input/output signature
    of our tool and handle incoming messages by dispatching them
    to the correct method.
  \item {\tt ExampleBridge.java}
    a \emph{concrete} class extending {\tt ExampleTool.java}
    which can be used as a bridge between your Tool class and
    the ToolBus.
\end{itemize}

Remember that Java only allows extention of a single class, but
\emph{does} allow your class to implement multiple interfaces. Using
the generated {\tt Bridge} allows your class to extend another
class, but still save you the arduous task of extending the generic
\emph{AbstractTool} class for each new tool. Have a look at the source
code of {\tt example.tb} and {\tt Example.java} below.

\noindent
{\tt example.tb} looks like this:
% {{{ example.tb

\begin{verbatim}

tool example is { command="java-adapter -class Example" }

process EXAMPLE is
let
  T : example,
  Value : int,
  Name  : str
in
  execute(example, T?) .
  (
    snd-eval(T, msg("Hello World!")) delay(sec(3)) .
    rec-value(T, count(Value?)) .
    printf("Hello number %d\n", Value)
  ) * delta 
  ||
  (
    rec-event(T, button(Name?)) .
    printf("Button pressed: %s\n", Name) .
    snd-ack-event(T, button(Name))
  ) * delta
endlet

toolbus(EXAMPLE)

\end{verbatim}

% }}}
\noindent
{\tt Example.java} looks like this:
% {{{  Example.java

\begin{verbatim}
import java.io.*;
import java.awt.*;
import java.awt.event.*;

import aterm.*;

public class Example
  extends Frame
  implements ExampleTif, ActionListener
{
  private ATermFactory factory;
  private ExampleBridge bridge;
  private Button button;
  private int count;

  public static final void main(String[] args)
    throws IOException
  {
    Example example = new Example(args);
  }

  public Example(String[] args)
    throws IOException
  {
    factory = new aterm.pure.PureFactory();

    // Build the user interface: just a single button
    button = new Button("Button");
    button.addActionListener(this);
    add(button);
    pack();
    show();

    // Create the bridge that will forward incoming messages
    // to method calls in this Example object
    bridge = new ExampleBridge(factory, this);

    // Initialize vital parameters, like the ToolBus TCP/IP port, tool name,
    // etc. that are passed to us using the command line arguments.
    bridge.init(args);
    
    // Actually establish the connection with the ToolBus
    bridge.connect();

    // Start the tool event loop
    bridge.run();
  }

  public void actionPerformed(ActionEvent event)
  {
    if (event.getSource() == button) {
      // When the user presses the button, we send an event to the ToolBus
      bridge.postEvent(factory.make("button(<str>)", button.getLabel()));
    }
  }

  public ATerm msg(String message)
  {
    // Print the incoming message
    System.out.println("Example tool received msg: " + message);

    // Increase the counter and return the current value to the ToolBus
    return factory.make("snd-value(count(<int>))", new Integer(count++));
  }

  public void recAckEvent(ATerm event)
  {
    // This simple tool ignores event acknowledgements
  }

  public void recTerminate(ATerm arg)
  {
    // Just exit when the ToolBus terminates
    System.exit(0);
  }
}
\end{verbatim}

% }}}

% }}}

%}}}

\end{document}
