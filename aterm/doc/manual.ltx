%{{{ LaTeX configuration

% vim:ts=4:sw=4:tw=75
\documentclass[a4paper,twoside]{article}

%\usepackage{fullpage}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{makeidx}
\usepackage{epsfig}

\makeindex

\newcommand{\ATlib}{ATerm Library}
\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}

%% notion of Symbol was changed to AFun, which matches specification.
\newcommand{\Symbol}{AFun}	

\newcommand{\ATtrue}{\mbox{\tt ATtrue}}
\newcommand{\ATfalse}{\mbox{\tt ATfalse}}
\newcommand{\main}{\mbox{\tt main}}
\newcommand{\ATinit}{\mbox{\tt ATinit}}
\newcommand{\ATprotect}{\mbox{\tt ATprotect}}
\newcommand{\ATprotectArray}{\mbox{\tt ATprotectArray}}

\newcommand{\toolbus}{\mbox{\tt ToolBus}}

% \example{init.c} will input file "examples/init.c" in verbatim mode.
\newcommand{\example}[1]{
	\noindent
	\hrulefill
	\begin{small}
	\verbatiminput{examples/#1}
	\end{small}
	\hrulefill
}

% NULL
\newcommand{\NULL}{{\tt NULL}}

% Function definition
\newcommand{\Function}[4]{
	\vspace{0.3cm}
	\noindent
	\framebox[12.6cm][l]{{\bf function:} {\tt #1}} \vspace{0.1cm}\newline
	\label{#1}
	\noindent
	{\bf Summary:\hspace{0.2cm}} #4\newline
	{\bf Declaration:}
		{\tt #2} {\tt #1}({\tt #3});
	\index{#1@{\tt #1}}
}

% Macro definition
\newcommand{\Macro}[4]{
	\vspace{0.3cm}
	\noindent
	\framebox[12.6cm][l]{{\bf macro:} {\tt #1}} \vspace{0.1cm}\newline
	\label{#1}
	\noindent
	{\bf Summary:\hspace{0.2cm}} #4\newline
	{\bf Declaration:}
		{\tt #2} {\tt #1}({\tt #3})
	\index{#1@{\tt #1}}
}

% Method definition
\newcommand{\Method}[4]{
	\vspace{0.3cm}
	\noindent
	\framebox[12.6cm][l]{{\bf method:} {\tt #1}} \vspace{0.1cm}\newline
	\label{#1}
	\noindent
	{\bf Summary:\hspace{0.2cm}} #4\newline
	{\bf Declaration:}
		{\tt #2} {\tt #1}({\tt #3});
	\index{#1@{\tt #1}}
}

% Throws exception (optional)
\newcommand{\Throws}[2]{

\noindent{\bf Throws:} {\tt #1} #2
}

% Function/Macro/Method description (optional)
\newcommand{\Describe}[1]{

	\noindent{\bf Description:} #1
}

\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\asfix{\mbox{\sc AsFix}}

%}}}
%{{{ Title page and table of contents

%----[ TITLE PAGE ]----

\title{\ATlib\ User Manual}
\author{Hayco de Jong \hspace{1cm} Pieter Olivier\\\\
{\small\sl University of Amsterdam,}\\
{\small\sl Programming Research Group,}\\
{\small\sl Kruislaan 403, 1098 SJ Amsterdam, The Netherlands}\\\\
{\small\sl E-mail: \tt jong@wins.uva.nl - olivierp@wins.uva.nl}}

\date{}
\begin{document}
\maketitle

\begin{abstract}
This report is a manual describing the functionality provided by the
\ATlib, a high performance implementation of the \ATerm\ datatype using
maximal sharing and automatic garbage collection.
\end{abstract}

\tableofcontents
\newpage

%}}}
%{{{ Introduction

%----[ INTRODUCTION ]----
\section{Introduction}\label{intro}
This manual describes the functionality provided by the \ATlib. The library
is a high performance implementation of the \aterm\ datatype described
in~\cite{BJO98}. If your application satisfies the following list of
characteristics, the \ATlib\ can probably prove to be a valuable component.

\begin{itemize}
\item Maximal sharing of terms is required;
\item Automatic garbage collection is required;
\item There is no need for destructive update of terms (e.g. the \ATlib\ is
not suited to implement stacks).
\end{itemize}

Typical applications that benefit from using the \ATlib\ are those that
manipulate (abstract syntax) trees or terms, and those that are related to
the new {\sc Asf+Sdf} Meta-Environment \cite{BKMO97} or the new {\sc
Asf+Sdf} compiler~\cite{BOHK98}.

This manual is intended to be a comprehensive text on how to use the
\ATlib.  Readers who are interested in the design details of the \ATlib,
can find these in~\cite{BJO98}.

Section~\ref{usage} explains the basic steps that must be taken to
initialise and work with the \ATlib.

The level one interface described in Section~\ref{lvl1} offers a set of
operations on \aterms\ that is sufficiently powerful for most users, yet is
concise enough to be mastered in a relatively short period of time.

Section~\ref{lvl2} describes the level two interface which is intented for
experienced \aterm\ users, providing a more extensive set of datastructures
and functions.

The \ATlib{} comes with a number of utility programs. A description of
these programs can be found in Section~\ref{utils}.

%}}}
%{{{ Using the ATerm library

%----[ USAGE ]----
\section{Using the \ATlib}\label{usage}
This section explains the basics of using the \ATlib. One design decision,
basing the \ATlib\ on maximally shared \ATerms, has some consequences that
readers should be familiar with before using the \ATlib.
Section~\ref{sharing} therefore addresses the notion of \emph{maximal
sharing} and its consequences on the use of \aterms.

The \ATlib\ has a built-in garbage collector. Section~\ref{gc} explains
what this garbage collector does and when it is invoked.

To use the \ATlib, it must first be initialised.  This ensures that the
garbage collector is activated and that all necessary internal structures
are set up. Section~\ref{init} demonstrates initialisation of the \ATlib\
and shows all possible commandline options. These alter the behaviour of the
\ATlib.

The garbage collector detects references to \aterms\ that are on the stack
and in any of the registers.  As it is also possible to have global
references to \aterms\ which the garbage collector cannot detect, it is the
user's responsibility to protect these references from premature erasure.
Section~\ref{prot} explains how to protect global \aterm\ variables and
arrays of \aterms.

The \ATlib\ is capable of storing \aterms\ in a compact, portable binary
notation.  Section~\ref{baf} describes this binary \aterm\ format.

%----[ SHARING ]---
\subsection{Maximal sharing}\label{sharing}
Although explaining the design details of the \ATlib\ is beyond the scope
of this manual, it is important that users realise that the \ATlib\ is
implemented using maximally shared \ATerms. This means that before a new
\ATerm\ is created, a lookup is done to see if that term already exists. If
so, that term is reused and no new term is created, resulting in maximally
shared terms. This has the advantage that equality of terms can be
expressed as being physically the same term, i.e., both terms must have the
same memory address. It also means that, as terms can be shared without the
user knowing it, they cannot be modified without creating unwanted side
effects. Thus, users should not tamper with \ATerms. Rather, they should
use the functionality provided in the level one and level two interfaces.

%----[ GARBAGE COLLECTOR]-
\subsection{Garbage collector}\label{gc}
The \ATlib\ uses garbage collection to find and delete unused \ATerms. This
relieves users of the burden of explicitly allocating and freeing every
\ATerm\ used in an application. Each time a new \ATerm\ is allocated the
garbage collector decides whether time has come to free resources claimed
by unused \ATerms\ or whether there still is enough space to create the
requested term. Details on the design and implementation of this garbage
collection can be found in~\cite{BJO98}.

%----[ INITIALISING ATERM LIBRARY ]----
\subsection{Initialising the \ATlib}\label{init}
To initialise the \ATlib, a call to \ATinit\ must be made from \main,
passing the commandline arguments stored in {\tt argc} and {\tt argv}.
The address of a locally created ATerm variable must also be passed.  This
address is used by the garbage collector to determine the bottom of the stack
to be inspected for \aterms.
The following code demonstrates a typical initialisation of the \ATlib.

\example{init.c}

\smallskip\noindent
The following commandline options can be passed to the \ATlib:
\medskip

\begin{tabular}{|l|l|}
 \hline
 {\tt -at-symboltable <nr\_symbols>} & Initial size of symboltable           \\
 {\tt -at-termtable <table\_class>}  & Start with termtable of
                                    $2^\textrm{table\_class}$ entries     \\
 {\tt -at-hashinfo} & write hashtable statistics to {\tt hashing.stats}      \\
				 & after execution \\
 {\tt -at-print-gc-time} & print timing information about garbage collector  \\
					  & to {\tt stderr} after execution \\
 {\tt -at-print-gc-info} & print verbose information about garbage collector \\
					  & to {\tt stderr} after execution \\
 {\tt -at-silent} & Do not print status and version information
 \\
 \hline
\end{tabular}

%----[ PROTECTING ATERMS]----
\subsection{Protecting global \aterms\ and arrays of \aterms}\label{prot}
During a garbage collect, the \ATlib\ searches the stack and registers for
\aterms. Therefore it finds all \aterms\ which were created locally in a
function (\emph{automatic} variables). All \aterm\ variables which were
\emph{not} created locally, must be protected by a call to \ATprotect. For
entire arrays of \aterms, \ATprotectArray\ should be used. Note that not
the \aterm\ variable itself, but its address is passed to \ATprotect.
Users of the level two interface who create a function application by
building the function symbol (\Symbol) can also keep global references to
these symbols. Such references should be protected through a call to {\tt
ATprotect\Symbol}.

The following code demonstrates the protection of a global \aterm\ and a
global array of \aterms.

\example{prot.c}

\subsection{Unprotecting protected \aterms}\label{unprot}
When the lifetime of an \aterm\ that was protected as described in
Section~\ref{prot} has expired, the \aterm\ should be unprotected to free any
internal resources it holds. Note that these resources are not released
immediately. Instead, they are no longer marked as protected to the garbage
collector and as such may be freed at the next garbage collection. For each
{\tt ATprotect} function, there is a matching {\tt ATunprotect} function.

%----[ BINARY ATERM FORMAT ]----
\subsection{Binary \aterm\ Format ({\sc baf})}\label{baf}
In addition to being able to parse terms in textual format and write
textual representations of \aterms, the \ATlib\ is also equipped to store
and restore \ATerms\ in a compact, portable binary representation. This
representation is called {\sc baf} which stands for ``Binary \ATerm\
Format''.

This format can be used to write a binary version of an \ATerm\ to file,
which can later be restored in a much more efficient way than would be
possible had the \ATerm's textual counterpart been used. This is due to the
fact that textual representations have to be (re-)parsed each time they are
read from file, whereas {\sc baf} directly describes how to rebuild the
internal representation of an \ATerm, thus skipping the parsing phase.
Moreover, the maximal sharing of \ATerms\ is exploited when writing {\sc
baf}-representations, making them take up much less space than their
textual representations would have needed.

Users of the \ATlib\ are encouraged to use {\sc baf} representations when
saving \aterms\ to file.  {\sc baf} was designed to be platform
independent, which facilitates the exchange of \ATerms. The \ATlib\ comes
with a utility that is able to convert an \ATerm's textual representation
into its {\sc baf} counterpart and vice versa (see
Section~\ref{util-baffle}). This conversion makes it possible to always
work with {\sc baf} representations, while still being able to look at the
textual representation any time an error is suspected. It also allows
conversion of textual \ATerms\ written by programs unable to write {\sc
baf} which is especially convenient when these \ATerms\ are bulky.

Although the \ATlib\ does not put any constraints on the names of \aterm-files,
users are encouraged to use the extension {\tt .baf} for {\sc baf} files.
This will avoid confusion between textual representations and binary ones.
Textual representations could use the extension {\tt .trm}.

%}}}
%{{{ Level One Interface

%--------------------[ LEVEL ONE INTERFACE ]--------------------

\section{Level One Interface}\label{lvl1}
This section explains in detail the types and functions that are defined in
the level one interface. These functions are declared in {\tt aterm1.h}.
Section~\ref{types1} reveals the types of \aterms\ that are used in the
\ATlib, as well as the extension to the standard {\tt C}-types introduced
in the level one interface. To avoid confusion between {\sc baf} and the
\aterm\ type \emph{blob}, Section~\ref{blob-vs-baf} is dedicated to
explaining the difference between these two notions. Finally,
Section~\ref{func1} describes all the functions that are available in the
level one interface.

\subsection{Level One Types}\label{types1}
The following {\tt C}-defines are used to represent the different \aterm\
types:
\begin{small}
\begin{itemize}
	\item {\tt AT\_FREE}: An \aterm\ that is marked \emph{free} will be
	reused when needed. This is not a type users will want to create
	themselves, but it can be used to detect an \aterm\ that has been freed
	by the garbage collector.
	\item {\tt AT\_APPL}:        An \aterm\ of type: function application;
	\item {\tt AT\_INT}:         An \aterm\ of type: integer;
	\item {\tt AT\_REAL}:        An \aterm\ of type: real;
	\item {\tt AT\_LIST}:        An \aterm\ of type: list;
	\item {\tt AT\_PLACEHOLDER}: An \aterm\ of type: placeholder;
	\item {\tt AT\_BLOB}:        An \aterm\ of type: binary large object;
\end{itemize}
\end{small}

The following {\tt C}-types are defined in the level one interface:
\begin{small}
\begin{itemize}
	\item {\tt ATbool}: a boolean value, either \ATtrue\ or \ATfalse;
	\item {\tt ATerm}: an annotated term.
\end{itemize}
\end{small}

\subsection{A note on `blobs' and {\sc baf}}\label{blob-vs-baf}
Please note that although the word \emph{binary} is used in the
abbreviations of both ``blob'' and {\sc baf}, these are two very different
notions.  A \emph{blob} represents an \aterm\ that holds binary data, with
no specific meaning to the \ATlib. This notion can be used as a means of
escape in case you find that you need a type of \aterm\ that is not on the
list above.  The notion of {\sc baf} is explained in Section~\ref{baf} and
refers to a specific format used for reading and writing \aterms.  Thus an
\aterm\ of type {\tt AT\_BLOB} can be saved in {\sc baf}. It could also be
written in its textual representation, although this does not guarantee
that the blob will be readable, after all it represents binary data.

\subsection{Level One Functionality}\label{func1}
In this section, all functions and macros ({\tt \#define}'s in {\tt C}) are
listed. Although all macros could have been implemented as a function as
well, the macros listed here were chosen to be macros instead of functions
for efficiency reasons. To obtain access to the level one interface, your
application should {\tt \#include <aterm1.h>}.

\Function{ATmake}{\ATerm}{const char *pattern, ...}
{Create an \ATerm\ from a string pattern and a variable number of arguments}
\Describe{
	Creates an \aterm\ given a pattern and corresponding values.
	The following table shows which patterns can be used, and which type
	of arguments should be passed if such a pattern is used.

	\smallskip
	\begin{small}
	\begin{tabular}{|l|l|l|}
	\hline
	Type & Pattern & Argument \\
	\hline
	Application & {\tt <appl>}        & {\tt char *pattern}, arguments \\
	Blob        & {\tt <blob>}        & {\tt int length}, {\tt void *data}\\
	Integer     & {\tt <int>}         & {\tt int value}\\
	List        & {\tt <list>}        & {\tt ATerm} \\
	Placeholder & {\tt <placeholder>} & {\tt char *type} \\
	Real        & {\tt <real>}        & {\tt double value}\\
	String      & {\tt <str>}         & {\tt char *pattern}, arguments \\
	Term        & {\tt <term>}        & {\tt ATerm} \\
	\hline
	\end{tabular}
	\end{small}

	\medskip\noindent
	Types {\tt <appl>} and {\tt <str>} should contain a pattern consisting
	of the function symbol to be used and the types of the arguments.  This
	pattern must be followed by exactly the number of arguments that are
	used in the pattern. The types of the arguments must match the
	respective types used in the pattern. Both {\tt <appl>} and {\tt <str>}
	create function applications. The difference is that {\tt <appl>}
	creates one with an \emph{unquoted} function symbol, whereas {\tt
	<str>} yields a \emph{quoted} version.

	\smallskip\noindent
	Here are some examples of {\tt ATmake}:

	\example{make.c}
}

\Function{ATvmake}{\ATerm}{const char *pattern, va\_list args}
{Create an \ATerm\ from a string pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{ATmakeTerm}{\ATerm}{\ATerm\ pat, ...}
{Create an \ATerm\ from an \ATerm\ pattern and a variable number of
arguments}
\Describe{See {\tt ATmake}.}

\Function{ATvmakeTerm}{\ATerm}{\ATerm\ pat, va\_list args}
{Create an \ATerm\ from an \ATerm\ pattern and a list of arguments}
\Describe{See {\tt ATmake}.}

\Function{ATmatch}{ATbool}{\aterm\ t, const char *pattern, ...}
{Match an \aterm\ against a pattern}
\Describe{
	Matches an \aterm\ against a pattern, attempting to fill the `holes'.
	If the \aterm\ matches the pattern, \ATtrue\ is returned and the
	variables will be filled according to the pattern, otherwise \ATfalse\
	is returned.

	The {\tt <list>} pattern can be used to match the tail of a list as
	well as a variable number of arguments in a function application. Thus
	the first few arguments may be matched explicitly while the tail of
	the arguments is directed to a list.


	\smallskip\noindent
	Here are a few examples of {\tt ATmatch}:

	\example{match.c}
}

\Function{ATreadFromString}{\ATerm}{const char *string}
{Read an \aterm\ from string}
\Describe{
	This function parses a character string into an \aterm.
	A convenience macro {\tt ATparse} is included in {\tt aterm1.h}.
}

\Function{ATreadFromTextFile}{\ATerm}{FILE *file}
{Read an \aterm\ from text file}
\Describe{
	This function reads a text file and parses the contents into an \aterm.
}

\Function{ATreadFromBinaryFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary file ({\sc baf})}
\Describe{
	This function reads a binary file and builds an \aterm.
}

\Function{ATreadFromFile}{\ATerm}{FILE *file}
{Read an \aterm\ from binary or text file}
\Describe{
	This function reads an \aterm\ from a file. A test is performed
	to see if the file is in {\sc baf}. If so, the binary term will
	be read, otherwise the textual representation will be parsed.
}

\Macro{ATparse}{\ATerm}{const char *str}
{A convenience macro for {\tt ATreadFromString}}
\Describe{
	This macro is simply a shortcut to {\tt ATreadFromString(str)}.
}

\Macro{ATgetType}{int}{\ATerm\ term}
{Return the type of {\tt term}}
\Describe{
	A macro that returns the type of an \aterm. Result is one of
	{\tt AT\_APPL}, {\tt AT\_INT}, {\tt AT\_REAL}, {\tt AT\_LIST},
	{\tt AT\_PLACEHOLDER}, or {\tt AT\_BLOB}.
}

\Macro{ATisEqual}{int}{\ATerm\ t1, \ATerm\ t2}
{A macro that tests equality of \aterms\ {\tt t1} and {\tt t2}}
\Describe{
	As \ATerms\ are created using \emph{maximal sharing} (see
	Section~\ref{sharing}), testing equality is performed in constant time
	by comparing the addresses of {\tt t1} and {\tt t2}}

\Function{ATwriteToTextFile}{ATbool}{\aterm\ t, FILE *f}
{Writes term {\tt t} to file {\tt f} in textual format}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in textual format.
	This term can later be read again by {\tt ATreadFromTextFile}.
}

\Function{ATwriteToBinaryFile}{ATbool}{\aterm\ t, FILE *F}
{Writes term {\tt t} to file {\tt f} in Binary ATerm Format ({\sc baf})}
\Describe{
	This function writes \aterm\ {\tt t} to the file {\tt f} in {\sc baf}.
	This term can later be read again by {\tt ATreadFromBinaryFile}.
}

\Function{ATwriteToString}{char *}{\aterm\ t}
{Writes term {\tt t} to a string}
\Describe{
	Writes term {\tt t} to an internal string buffer. The start of this
	buffer is returned. Note that the contents of this buffer are volatile
	and may be overwritten by any call to the \ATlib.
}

\Function{ATsetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label, \aterm\ anno}
{Annotate a term with a labeled annotation}
\Describe{
	Creates a version of {\tt t} that is annotated with annotation {\tt anno}
	which is labeled by {\tt label}.
}

\Function{ATgetAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Retrieves annotation of {\tt t} with label {\tt label}}
\Describe{
	This function can be used to retrieve a specific annotation of a term.
	If {\tt t} has no annotations, or no annotation labeled with {\tt label}
	exists, \NULL\ is returned. Otherwise the annotation is returned.
}

\Function{ATremoveAnnotation}{\ATerm}{\aterm\ t, \aterm\ label}
{Remove a specific annotation from a term}
\Describe{
	This function returns a version of {\tt t} which has its annotation with
	label {\tt label} removed. If {\tt t} has no annotations, or no annotation
	labeled with {\tt label} exists, {\tt t} itself is returned.
}

\Function{ATinit}{void}
{\tt int argc, char *argv[], \aterm\ *bottomOfStack}
{Initialise the \ATlib.}
\Describe{See Section~\ref{init}.}

\Function{ATprintf}{int}{const char *format, ...}
{\ATerm\ version of {\tt printf}}
\Describe{See ATvfprintf.}

\Function{ATfprintf}{int}{FILE *stream, const char *format, ...}
{\ATerm\ version of {\tt fprintf}}
\Describe{See ATvfprintf.}

\Function{ATvfprintf}{int}{FILE *stream, const char *format, va\_list args}
{\ATerm\ version of {\tt vfprintf}}
\Describe{
	The functions {\tt ATprintf}, {\tt ATfprintf} and {\tt ATvfprintf}
	are used for formatted output to file. The conversion specifiers
	{\tt c, d, i, o, u, x, X, e, E, f, g, G, p, s} behave as can be
	expected from {\tt (f)printf}. In addition the conversion specifiers
	{\tt l, n, t} and {\tt y} are supported:

	\begin{small}
	\begin{center}
	\begin{tabular}{|c|l|}
	\hline
	Conversion specifier & Action \\
	\hline
	{\tt l} & print an \aterm-list \\
	{\tt n} & print information about an \aterm\ node \\
	{\tt t} & print an \aterm \\
	{\tt y} & print the symbol of an \aterm-application \\
	\hline
	\end{tabular}
	\end{center}
	\end{small}
}
		
\Function{ATsetErrorHandler}{void}
{\tt (void (*handler)(const char *, va\_list))}
{Specify an errorhandler for the \ATlib.}
\Describe{
	This function can be used to set up an errorhandler for the \ATlib.
	This handler will be called when an error message is sent to {\tt
	ATerror}.  If no handler is set, the message is printed to {\tt stderr}
	through {\tt ATfprintf} and the \ATlib\ then calls {\tt abort()}.  }

\Function{ATerror}{void}{(const char *format, ...)}
{Dump an errormessage and abort the \ATlib}
\Describe{
	If an errorhandler has been installed through a call to
	{\tt ATsetErrorHandler}, this handler will be called. Otherwise
	{\tt ATerror} prints a formatted message to {\tt stderr}, through
	{\tt ATvfprintf} (q.v.) followed by a call to {\tt abort}.
}

\Function{ATprotect}{void}{\aterm\ *atp}{Protect an \aterm}
\Describe{
	Protects an \aterm\ from being freed at garbage collection. See
	Section~\ref{prot}.
}

\Function{ATunprotect}{void}{\aterm\ *atp}{Unprotect an \aterm}
\label{at-unprot}
\Describe{
	Releases protection of an \aterm\ which has previously been protected
	through a call to {\tt ATprotect}. See Section~\ref{unprot}.
}

\Function{ATprotectArray}{void}{\aterm\ *start, int size)}
{Protect an array of \ATerms}
\label{at-unprot-arr}
\Describe{
	Protects an entire array of {\tt size} \aterms\ starting at {\tt start}.
}

\Function{ATunprotectArray}{void}{\aterm\ *start)}
{Unprotect an array of \ATerms}
\Describe{
	Releases protection of the array of \aterms\ which starts at {\tt
	start}.
}

%--------------------[ LEVEL TWO INTERFACE ]--------------------

%}}}
%{{{ Level Two Interface

\section{Level Two Interface}\label{lvl2}
This section explains in detail the types and functions that are defined in
the level two interface. These functions are declared in {\tt aterm2.h}

\subsection{Level Two Types}\label{types2}
In addition to the C-types explained in Section~\ref{types1}, the level two
interface also uses the following types:
\begin{itemize}
	\item {\tt ATermInt}: an integer value;
	\item {\tt ATermReal}: a real value;
	\item {\tt ATermAppl}: a function application;
	\item {\tt ATermList}: a list;
	\item {\tt ATermPlaceholder}: a placeholder;
	\item {\tt ATermBlob}: a Binary Large OBject;
	\item {\tt ATermTable}: a hashtable of \aterms;
\end{itemize}

\subsection{Level Two Functionality}\label{func2}
This section describes all functions and macros that are available in the
level two interface. To obtain access to this functionality you need to
{\tt \#include <aterm2.h>} instead of {\tt <aterm1.h>} in your application.

In Section~\ref{func1} we explained that the macros used in the level one
interface could just as well have been implemented as functions, but were
chosen to be implemented as macros for efficiency reasons. The same goes
for all macros described in this section.

\subsubsection{ATermInt}
The type {\tt ATermInt} is the \ATerm\ representation of an integer. It
abides by the rules of the {\tt C}-type: {\tt int}.

\Function{ATmakeInt}{ATermInt}{int value}
{Build an \aterm Int from an integer ({\tt int})}

\Macro{ATgetInt}{int}{\ATerm\ t}
{Get the integer value from an \aterm Int.}

\subsubsection{ATermReal}
The type {\tt ATermReal} is the \ATerm\ representation of a real. It
abides by the rules of the {\tt C}-type: {\tt double}.

\Function{ATmakeReal}{ATermReal}{double value}
{Build an \aterm Real from a real ({\tt double}).}

\Macro{ATgetReal}{double}{\ATerm\ t}
{Macro to get the real value from an \aterm Real.}

\subsubsection{ATermAppl}
The type {\tt ATermAppl} denotes a function application. In order to build
a function application, first its function symbol (\Symbol) must be built.
This symbol holds the name of the function application, its arity (how many
arguments the function has) and whether the function name is quoted. Below
are some examples of function applications and the symbols needed to create
them.

\begin{small}
\begin{verbatim}
    true               - a zero arity, unquoted function application
                         sym = ATmakeAFun("true", 0, ATfalse);

    "true"             - the same function application, but quoted
                         sym = ATmakeAFun("true", 0, ATtrue);

    f(0)               - an unquoted function application of arity 1
                         sym = ATmakeAFun("f", 1, ATfalse);

    "prod"(2, b, [])   - a quoted function application of arity 3
                         sym = ATmakeAFun("prod", 3, ATtrue);
\end{verbatim}
\end{small}

\Function{ATmake\Symbol}{\Symbol}
{\tt char *name, int arity, ATbool quoted}
{Create a function symbol (\Symbol)}
\Describe{
	Creates an \Symbol, representing a function symbol with name {\tt name}
	and arity {\tt arity}. Quotedness is passed through the {\tt quoted}
	argument.
}

\Function{ATprotect\Symbol}{void}{\Symbol\ sym}
{Protect a function symbol}
\label{at-unprot-sym}
\Describe{Just as \aterms\ which are not on the stack or in registers must
	be protected through a call to {\tt ATprotect}, so must \Symbol s be
	protected by calling {\tt ATprotect\Symbol}.
}

\Function{ATunprotect\Symbol}{void}{\Symbol\ sym}
{Release an \Symbol's protection.}

\Macro{ATgetName}{char *}{\Symbol\ sym}
{Return the name of an \Symbol}.

\Macro{ATgetArity}{int}{\Symbol sym}
{Return the arity (number of arguments) of a function symbol (\Symbol)}

\Macro{ATisQuoted}{ATbool}{\Symbol\ sym}
{Determine if a function symbol (\Symbol) is quoted or not}

\Function{ATmakeAppl}{ATermAppl}{\Symbol\ sym, ...}
{Build an application from an \Symbol\ and a variable number of arguments.}
\Describe{
	The arity is taken from the first argument {\tt sym}, the other
	arguments to {\tt ATmakeAppl} should be the arguments for the
	application. For arity $0\ldots 6$ the corresponding {\tt ATmakeAppl<N>}
	can be used instead for greater efficiency.  }

\Function{ATmakeAppl0}{ATermAppl}{\Symbol\ s}
{Make a function application with zero arguments}

\Function{ATmakeAppl1}{ATermAppl}{\Symbol\ s, \ATerm\ a0}
{Make a function application with one argument}

\Function{ATmakeAppl2}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1}
{Make a function application with two arguments}

\Function{ATmakeAppl3}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2}
{Make a function application with three arguments}

\Function{ATmakeAppl4}{ATermAppl}{\Symbol\ s, \ATerm\ a0, a1, a2, a3}
{Make a function application with four arguments}

\Function{ATmakeAppl5}{ATermAppl}{\Symbol\ s,
	\ATerm\ a0, a1, a2, a3, a4}
{Make a function application with five arguments}

\Function{ATmakeAppl6}{ATermAppl}
{\Symbol\ s, \ATerm\ a0, a1, a2, a3, a4, a5}
{Make a function application with six arguments}
\Describe{
	These functions build an application of arity zero through six, i.e.
	an application with $0\ldots 6$ arguments. Use these functions to
	build {\tt ATermAppl}s with small arity in favour of the generic
	{\tt ATmakeAppl} described above.
}

\Macro{ATget\Symbol}{\Symbol}{ATermAppl appl}
{Get the function symbol (\Symbol) of an application}

\Macro{ATgetArgument}{\ATerm}{ATermAppl appl, int nr}
{Get the {\tt nr}-th argument of an application}

\Function{ATsetArgument}{ATermAppl}{ATermAppl appl, ATerm arg, int n}
{Set the {\tt nr}-th argument of an application to {\tt arg}}
\Describe{
	This function returns a copy of {\tt appl} with argument {\tt n}
	replaced by {\tt arg}.
}

\Function{ATgetArguments}{ATermList}{ATermAppl appl}
{Get a list of arguments of an application}
\Describe{
	Return the arguments of {\tt appl} in {\tt ATermList} format.
	Note: traversing the arguments of {\tt appl} can be done more
	efficiently using the {\tt ATgetArgument} macro.
}

\Function{ATmakeApplList}{ATermAppl}{\Symbol\ sym, ATermList args}
{Build an application given an \Symbol\ and a list of arguments}
\Describe{
	Build an application from {\tt sym} and the argument list {\tt args}.
	Note: unless the arguments are already in an {\tt ATermList}, it is
	probably more efficient to use the appropriate {\tt ATmakeAppl<N>}.
}

\Function{ATmakeApplArray}{ATermAppl}{\Symbol\ sym, ATerm args[]}
{Build an application given an \Symbol\ and an array of arguments}

\subsubsection{ATermList}
\Function{ATmakeList}{ATermList}{int n, ...}
{Create an {\tt ATermList} of $n$ elements}
\Describe{
	This function can be used to build an {\tt ATermList} of $n$ elements.
	The elements should be passed as arguments $1\ldots n$.
}

\Macro{ATmakeList0}{ATermList}{}
{Macro defined to point to the empty list {\tt []}}

\Function{ATmakeList1}{ATermList}{\ATerm\ el0}
{Construct a list of one element}

\Function{ATmakeList2}{ATermList}{\ATerm\ el0, el1}
{Construct a list of two elements}

\Function{ATmakeList3}{ATermList}{\ATerm\ el0, el1, el2}
{Construct a list of three elements}

\Function{ATmakeList4}{ATermList}{\ATerm\ el0, el1, el2, el3}
{Construct a list of four elements}

\Function{ATmakeList5}{ATermList}{\ATerm\ el0, el1, el2, el3, el4}
{Construct a list of five elements}

\Function{ATmakeList6}{ATermList}{\ATerm\ el0, el1, el2, el3, el4, el5}
{Construct a list of six elements}
\Describe{
	These functions build an {\tt ATermList} of $1\ldots 6$ elements.
	Longer lists should be created using the generic {\tt ATmakeList}
	function described above.
}

\Macro{ATgetLength}{int}{ATermList l}
{Macro to get the length of list {\tt l}}

\Macro{ATgetFirst}{\ATerm}{ATermList l}
{Macro to get the first element of list {\tt l}}

\Macro{ATgetNext}{ATermList}{ATermList l}
{Macro to get the next part (the tail) of list {\tt l}}

\Macro{ATisEmpty}{ATbool}{ATermList l}
{Macro to test if list {\tt l} is empty}

\Function{ATgetPrefix}{ATermList}{ATermList list}
{Return all but the last element of {\tt list}}

\Function{ATgetLast}{\ATerm}{ATermList list}
{Return the last element of {\tt list}}

\Function{ATgetSlice}{ATermList}
{ATermList list, int start, int end}
{Get a portion (slice) of a list}
\Describe{
	Return the portion of {\tt list} that lies between {\tt start} and
	{\tt end}. Thus {\tt start} is included, {\tt end} is not.
}

\Function{ATinsert}{ATermlist}{ATermList list, \ATerm\ el}
{Return {\tt list} with {\tt el} inserted.}
\Describe{
  The behaviour of {\tt ATinsert} is of constant complexity.  That is, the
  behaviour of {\tt ATinsert} does not degrade as the length of {\tt list}
  increases.  }

\Function{ATinsertAt}{ATermList}
{(ATermList list, \ATerm\ el, int index}
  {Return {\tt list} with {\tt el} inserted at position {\tt index}}

\Function{ATappend}{ATermList}{ATermList list, ATerm el}
{Return {\tt list} with {\tt el} appended to it}
\Describe{
  Note that {\tt ATappend} is implemented in terms of {\tt ATinsert} by
  making a new list with {\tt el} as the first element and then {\tt
  ATinsert}ing all elements from {\tt list}. As such, the complexity of
  {\tt ATappend} is linear in the number of elements in {\tt list}.

  When {\tt ATappend} is needed inside a loop that traverses a list (see
  {\tt parse\_list1} below), behaviour of the loop will demonstrate
  quadratic complexity.

  \example{app1.c}\smallskip

  To avoid this behaviour, the inner loop could use {\tt ATinsert} instead
  of {\tt ATappend} to make the new list. This will cause the resulting
  list to be in reverse order. A single {\tt ATreverse} must therefore be
  performed, but this can be done after the loop has terminated, bringing
  the behaviour down from quadratic to linear complexity, but at the cost
  of two {\tt ATinsert}s per element (one for each {\tt ATinsert} in the
  loop, and an implicit one for each element through the use of {\tt
  ATreverse}).  An example is shown here in the implementation of {\tt
  parse\_list2}.

  \example{app2.c}\smallskip

  An even further optimisation could make use of a locally allocated
  buffer.  While traversing the list, all elements that would normally be
  {\tt ATappend}ed, are now placed in this buffer. Finally, the result is
  obtained by starting with an empty list and {\tt ATinsert}ing all
  elements from this buffer in reverse order. As the cost of allocating and
  freeing a local buffer is by no means marginal, this solution should
  probably only be applied when the loop appends more than just a few
  elements. The following example shows such an implementation in {\tt
  parse\_list3}.

  \example{app3.c}
}

\Function{ATconcat}{ATermList}{ATermList list1, ATermList list2}
{Return the concatenation of {\tt list1} and {\tt list2}}

\Function{ATindexOf}{int}{ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list}
\Describe{
	Return the index where {\tt el} can be found in {\tt list}. Start
	looking at position {\tt start}. Returns {\tt -1} if {\tt el} is
	not in {\tt list}.
}

\Function{ATlastIndexOf}{int}
{\tt ATermList list, ATerm el, int start)}
{Return the index of an \ATerm\ in a list (reverse)}
\Describe{
	Search backwards for {\tt el} in {\tt list}. Start searching at
	{\tt start}. Return the index of the first occurrence of {\tt l}
	encountered, or {\tt -1} when {\tt el} is not present before
	{\tt start}.
}

\Function{ATelementAt}{\ATerm}{ATermList list, int index)}
{Return a specific element of a list}
\Describe{
	Return the element at position {\tt index} in {\tt list}. Return
	\NULL\ when {\tt index} is not in {\tt list}.
}

\Function{ATremoveElement}{ATermList}{ATermList list, \ATerm\ el}
{Return {\tt list} with one occurrence of {\tt el} removed}

\Function{ATremoveAll}{ATermList}{ATermList list, \ATerm\ el}
{Return {\tt list} with all occurrences of {\tt el} removed}

\Function{ATremoveElementAt}{ATermList}
{\tt ATermList list, int index}
{Return {\tt list} with the element at {\tt index} removed}

\Function{ATreplace}{ATermList}{ATermList list, \ATerm\ el, int idx}
{Return {\tt list} with the element at {\tt index} replaced by {\tt el}}

\Function{ATreverse}{ATermList}{ATermList list)}
{Return {\tt list} with its elements in reversed order}

\Function{ATfilter}{ATermList}
{ATermList list, ATbool (*predicate)(ATerm)}
{Filter entries from a list using a predicate}
\Describe{
 This function can be used to filter entries that satisfy a given predicate
 from a list. Each item in {\tt list} is judged through a call to {\tt
 predicate}. If {\tt predicate} returns {\tt ATtrue} the entry is added to
 a list, otherwise it is skipped. The function returns the list containing
 exactly those items that satisfy {\tt predicate}.
}

\subsubsection{ATermPlaceholder}
A placeholder is a special subtype used to indicate a typed hole in an
\ATerm. This can be used to create a term of a specific type, even though
its actual contents are not filled in.

\Function{ATmakePlaceholder}{ATermPlaceholder}{\ATerm\ type}
{
  Build an \aterm Placeholder of a specific type. The type is taken from
  the {\tt type} parameter. See {\tt demo\_placeholder} below.
}

\Macro{ATgetPlaceholder}{\ATerm}{\ATerm Placeholder ph}
{Get the type of an \aterm Placeholder}

\example{plac.c}

\subsubsection{ATermBlob}
\Function{ATmakeBlob}{ATermBlob}{int size, void *data)}
{Build a Binary Large OBject given {\tt size} (in bytes) and {\tt data}}
\Describe{
 This function can be used to create an \aterm\ of type blob, holding
 the data pointed to by {\tt data}. No copy of this data area is made, so
 the user should allocate this himself.

 Note: due to the internal representation of a blob, size cannot exceed
 $2^{24}$ in the current implementation. This limits the size of the data
 area to 16 Mb.
}

\Macro{ATgetBlobData}{void *}{ATermBlob blob}
{Get the data section of {\tt blob}}

\Macro{ATgetBlobSize}{int}{ATermBlob blob}
{Get the size (in bytes) of {\tt blob}}

\Function{ATregisterBlobDestructor}{void}
{ATbool (*destructor)(ATermBlob)}
{Register a blob-destructor function}
\Describe{
 When a blob-destructor function has been registered, it will be called
 whenever the garbage collector deletes an ATermBlob. The destructor
 function can then handle the deletion of the data area of the blob. At
 most 16 blob destructor functions can be registered in the current
 implementation.
}

\Function{ATunregisterBlobDestructor}{void}
{ATbool (*destructor)(ATermBlob)}
{Unregister a previously registered blob-destructor function}
\Describe{
	This removes a blob-destructor that has been previously installed
	through a call to {\tt ATregisterBlobDestructor}.
}

\subsection{Dictionaries}\label{dicts}
Dictionaries are datastructures which allow looking up a certain \ATerm\
given another \ATerm. The dictionary itself is also an \aterm\ and as such
is subject to the \ATlib\ rules of garbage collection. Each dictionary
consists of its own list of \ATerms. For each lookup in the dictionary,
the list is traversed to see if the current element's key matches the one
being looked up. A lookup in a dictionary demonstrates behaviour linear in
the number of elements the dictionary contains. On average fifty percent of
the number of elements in the dictionary are examined before a match is
found (if the element is present at all). For a more efficient
\ATerm-to-\ATerm\ mapping, see Tables in section~\ref{tables}.

\Function{ATdictCreate}{\ATerm}{}{Create a new dictionary}

\Function{ATdictGet}{\ATerm}{\ATerm\ dict, \ATerm\ key}
{Get the value belonging to a given key in a dictionary.}

\Function{ATdictPut}{\ATerm}
{\ATerm\ dict, \ATerm\ key, \ATerm\ value}
{Add / update a (key, value)-pair in a dictionary}
\Describe{
 If {\tt key} does not already exist in the dictionary, this function adds
 the ({\tt key}, {\tt value})-pair to the dictionary. Otherwise, it updates
 the value to {\tt value}. The modified dictionary is returned.
}

\Function{ATdictRemove}{\ATerm}{\ATerm\ dict, \ATerm\ key}
{Remove the ({\tt key}, value)-pair from the dictionary}
\Describe{
	This function can be used to remove an entry from the dictionary.
	If the entry was actually in the dictionary, the modified dictionary is
	returned. If the entry was not in the dictionary in the first place,
	the (unmodified) dictionary itself is returned.
}

\subsection{Tables}\label{tables} The dictionaries described in
Section~\ref{dicts} are in essence nothing more than linked lists, which
makes them less suitable for large \aterm-to-\aterm\ mappings. To this end,
\ATerm\ tables were created. These are implemented as hashtables of
\aterms, with each hashbucket implemented as a dictionary.

\Function{ATtableCreate}{ATermTable}{int initial\_size, int max\_load\_pct}
{Create an ATermTable}
\Describe{
 This function creates an ATermTable given an initial size and a maximum
 load percentage. Whenever this percentage is exceeded (which is detected
 when a new entry is added through {\tt ATtablePut}), the table is
 automatically expanded and all existing entries are rehashed into the new
 table.  If you know in advance approximately how many items will be in the
 table, you may set it up in such a way that no resizing (and thus no
 rehashing) is necessary. For example, if you expect about $1000$ items in
 the table, you can create it with its initial size set to $1333$ and a
 maximum load percentage of $75\%$. You are not required to do this, it
 merely saves a runtime expansion and rehashing of the table which
 increases efficiency.
}

\Function{ATtableDestroy}{void}{ATermTable table}
{Destroy an ATermTable}
\Describe{
 Contrary to ATermDictionaries, ATermTables are themselves \emph{not}
 \ATerms. This means they are \emph{not} freed by the garbage collector
 when they are no longer referred to. Therefore, when the table is no
 longer needed, the user should release the resources allocated by the
 table by calling {\tt ATtableDestroy}. All references the table has to
 \aterms\ will then also be removed, so that those may be freed by the
 garbage collector (if no other references to them exist of course).
}

\Function{ATtablePut}{void}{ATermTable table, ATerm key, ATerm value}
{Add / update a (key, value)-pair in a table}
\Describe{
 If {\tt key} does not already exist in the table, this function adds the
 ({\tt key}, {\tt value})-pair to the table. Otherwise, it updates the
 value to {\tt value}.
}

\Function{ATtableGet}{ATerm}{ATermTable table, ATerm key}
{Get the value belonging to a given key in a table}


\Function{ATtableRemove}{void}{ATermTable table, ATerm key}
{Remove the ({\tt key}, value)-pair from {\tt table}}

\Function{ATtableKeys}{ATermList}{ATermTable table}
{Get an ATermList of all the keys in a table}
\Describe{
 This function can be useful if you need to iterate over all elements in a
 table. It returns an ATermList containing all the keys in the table. The
 corresponding values of each key you are interested in can then be
 retrieved through respective calls to {\tt ATtableGet}.
}

%}}}
%{{{ Utilities

\section{Utilities}\label{utils}
This section describes the utilities that come with the \ATlib. These
utilities are automatically built when the \ATlib\ is compiled and
installed.

\subsection{\ATerm-conversion: {\tt baffle}}\label{util-baffle}
This utility can be used to convert {\sc baf} to text and vice versa.
It also offers the option of interpreting a {\sc baf}-file. This will show
the commands which are executed to (re-)build the \aterm. This option was
created to aid debugging {\sc baf}-files and is probably of little use to
the regular \ATlib\ user.
\smallskip\noindent
\begin{small}
\begin{verbatim}
Usage: baffle [-i <input>] [-o <output> | -c] [-v] [-rb | -rt] [-wb | -wt]
 
    -i <input>    - Read input from file <input>        (Default: stdin)
    -o <output>   - Write output to file <output>       (Default: stdout)
    -c            - Check validity of input-term
    -v            - Print version information
    -h            - Display help
    -ri           - Write interpretation of BAF-input
    -rb, -rt      - Choose between BAF and TEXT input   (Default: -rb)
    -wb, -wt      - Choose between BAF and TEXT output  (Default: -wb)
\end{verbatim}
\end{small}

\subsubsection{\tt trm2baf}
A small script called {\tt trm2baf} is included which can be used to
connect a process producing textual output and a process which expects {\sc
baf} input. It just sets up {\tt baffle} with the appropriate switches and
redirects {\tt stdin} and {\tt stdout} accordingly.

\subsubsection{\tt baf2trm}
A small script called {\tt baf2trm} is included which can be used to
connect a process producing {\sc baf} output and a process which expects
textual input. It just sets up {\tt baffle} with the appropriate switches
and redirects {\tt stdin} and {\tt stdout} accordingly.

\subsection{Calculating an \ATerm's size: {\tt termsize}}
\label{util-termsize}
This utility can be used to calculate three things:
\begin{itemize}
  \item core size: the amount of memory a given \aterm\ needs;
  \item text size: the amount of memory needed to hold a textual
  representation of an \aterm;
  \item tree depth: the maximum depth of a term.
\end{itemize}
The results are written to {\tt stdout}. As {\tt termsize} uses {\tt
ATreadFromFile}, it can calculate the size of both textual and {\sc baf}
representations of \aterms.

\smallskip\noindent Usage: {\tt termsize < }\emph{inputfile}.

%}}}
%{{{ Index

%----[ INDEX ]----

\renewcommand{\indexname}
	{Index\addcontentsline{toc}{section}{\numberline{}Index}}
\printindex

%}}}
%{{{ Bibliography

%----[ BIBLIOGRAPHY ]----
\bibliographystyle{alpha}
\bibliography{thesis}

%}}}

\appendix

%{{{ The Java implementation

\section{Java implementation}

Besides the C implementaton discussed upto now, we also developed
a Java implementation of the ATerm datatype. We have tried to
keep the interfaces of the C implementation and the Java implementation
as close together as possible. Unfortunately, constraints imposed by
both languages prohibit the use of a single interface for both languages.
In this section we will discuss the Java interface, and highlight the
differences with the C interface where appropriate.

Most differences are introduced by the fact that Java is a much more
powerful language than C. Garbage collection for instance is a built-in 
feature of the Java language, so no {\tt protect} and {\tt unprotect}
functions are needed in Java.

\emph{Note that the Java version is still experimental, and therefore
subject to change!}

%{{{ Class hierarchy

\subsection{Class hierarchy}

Because Java is an object oriented language, we have partitioned
the Java implementation in a number of classes. The resulting class
hierarchy is shown in Figure \ref{class-hierarchy}.

\begin{figure}[htb]
\centerline{\epsfig{scale=0.5, file=hierarchy.ps}}
\caption{\label{class-hierarchy}Simple ATerm class library}
\end{figure}

Each of the subclasses of the abstract base class {\tt ATerm} represents 
one of the \aterm\ types. The {\tt ATerm} class also implements the
Level 1 functionality discussed earlier. This means that users who only need
to use this Level 1 interface, only need to get familiar with the class
{\tt ATerm} and its methods!

The class {\tt World} is used to implement maximal sharing, and is 
normally not used directly by the users of the \aterm\ library.

%}}}

%{{{ The class ATerm

\subsection{The class {\tt ATerm}}

This class implements the basic functionality to create and manipulate
\aterms. 

%{{{ Creating ATerm objects

\subsubsection{Creating {\tt ATerm} objects}
Because of the need to maintain maximal sharing, users of the
\aterm\ library do not create {\tt ATerm} objects directly using one
of its constructors, but instead use one of the following static methods 
in the {\tt ATerm} class:

\Method{parse}{\ATerm}{String string}
{Parse an \aterm\ from its string representation}
\Throws{ParseError}{when {\tt string} is not a valid term.}
\Describe{
	This function takes a String as input and tries to parse
        it as an ATerm. If {\tt string} represents a valid \aterm,
        an \ATerm\ object is returned. If the parsing fails, 
	a ParseError is thrown.
}

\Method{readFromTextFile}{\ATerm}{InputStream i}
{Read an \aterm\ from an {\tt InputStream}}
\Throws{IOException}{when an I/O error occurs.}
\Throws{ParseError}{when the string read from {tt i} is not a valid term.}
\Describe{
  This function takes an InputStream as input and reads one byte at
  a time. Note that the current implementation can only handle ASCII
  characters, not full Unicode.}

\Method{make}{\ATerm}{String pattern,Object arg1,Object arg2,...,Object argn}
{Parse a pattern and fill in the placeholders in it using {\tt arg1}
through {\tt argn}.}
\Throws{ParseError}{when {\tt pattern} does not represent a valid term.}
\Describe{
  The rules for matching are the same as in the {\tt ATmatch} function in
  the C library.
  Note that this is not a single method but rather a set of six different
  methods, one for each number of {\tt arg} arguments from zero to five.
  When you need to use a pattern with more than five placeholders, you
  must use the more general {\tt make} method described next.
  When the number of placeholders in {\tt pattern} is larger than the
  number of actual {\tt arg} arguments, a {\tt RuntimeException} is
  thrown. When the number of placeholders is less than the number of
  arguments, the excess arguments are ignored. When the type of one
  of the arguments does not match the placeholder type as shown
  in the following table, a {\tt ClassCastException} is thrown.
}

\begin{tabular}{|l|l|}
\hline
Placeholder   & Argument type \\
              &               \\
\hline
{\tt <int>}   & Integer       \\
{\tt <real>}  & Double        \\
{\tt <str>}   & String        \\
{\tt <appl>}  & String        \\
{\tt <term>}  & ATerm         \\
{\tt <list>}  & ATermList     \\
\hline
\end{tabular}

%}}}
%{{{ Analyzing terms

\subsection{Analyzing terms}
Besides creating terms, you can also analyze them using the methods
described here.

\Method{getType}{int}{}
{Retrieve the type of this \ATerm\ object.}
\Describe{This method returns one of the following
possible constants, indicating the type of the \ATerm\ object:
\begin{itemize}
\item {\tt ATerm.AT\_INT}: The object is of type {\tt ATermInt}
\item {\tt ATerm.AT\_REAL}: The object is of type {\tt ATermReal}
\item {\tt ATerm.AT\_APPL}: The object is of type {\tt ATermAppl}
\item {\tt ATerm.AT\_LIST}: The object is of type {\tt ATermList}
\item {\tt ATerm.AT\_PLACEHOLDER}: The object is of type {\tt ATermPlaceholder}
\item {\tt ATerm.AT\_BLOB}: The object is of type {\tt ATermBlob}
\end{itemize}
In principle, the {\tt instanceof} operator can be used to
retrieve the same information. However, the {\tt getType} method is much
faster and the resulting integer value can be used in a {\tt switch}
statement, while the {\tt instanceof} operator is only a boolean
predicate.
}

\Method{match}{Vector}{String pattern}
{Match a term against a String pattern, possibly yielding a list of subterms
matching with placeholders.}
\Throws{ParseError}{when {\tt pattern} does not represent a valid term.}
\Describe{
The pattern is parsed as an \ATerm, and the result is matched against
the object this method is called on. When the match succeeds, a {\tt Vector}
is returned containing a list of objects resulting from matches of subterms
with placeholders in the pattern. When the match fails, {\tt null} is 
returned.
}

\Method{match}{Vector}{ATerm pattern}
{Match a term against a \ATerm\ pattern, possibly yielding a list of
subterms matching with placeholders.}
\Describe{
{\tt pattern} is matched against
the object this method is called on. When the match succeeds, a {\tt Vector}
is returned containing a list of objects resulting from matches of subterms
with placeholders in the pattern. When the match fails, {\tt null} is 
returned.
}

\Method{isEqual}{boolean}{ATerm term}
{Perform an equality check between two \ATerms}
\Describe{Because of the maximal sharing, this operation is very cheap
because no deep equality check is needed.}

%}}}
%{{{ Output methods

\subsubsection{Output methods}
Some methods are needed to convert \ATerms\ to {\tt String}s and to
write \ATerms\ to {\tt OutputStream}s and {\tt PrintWriter}s.

\Method{writeToTextFile}{void}{OutputStream s}
{Write an \ATerm\ to an {\tt OutputStream}.}
\Throws{IOException}{When an I/O error occured}

\Method{print}{void}{OutputStream s}
{Print an \ATerm\ to an {\tt OutputStream}.}
\Describe{The only difference with the method {\tt writeToTextFile}
is that this method does not throw an {\tt IOException} when something
goes wrong, but instead fails silently.}

\Method{writeToString}{String}{}
{Return the {\tt String} representation of an \ATerm.}

%}}}

%}}}
%{{{ The class ATermInt

\subsection{The class {\tt ATermInt}}

This class is used to represent integer terms. It has only one
useful method:

\Method{getInt}{int}{}
{Retrieve the integer value held by this \ATerm.}

%}}}
%{{{ The class ATermReal

\subsection{The class {\tt ATermReal}}

This class is used to represent real valued terms. It has only one
useful method:

\Method{getReal}{double}{}
{Retrieve the real value held by this \ATerm.}

%}}}
%{{{ The class ATermAppl

\subsection{The class {\tt ATermAppl}}

This class is used to represent function applications. 
It adds the following methods to the {\tt ATerm} base class:

\Method{getName}{String}{}
{Retrieve the function name of this function application.}

\Method{isQuoted}{boolean}{}
{Ask if this function application has a quoted function name.}

\Method{getArity}{int}{}
{Retrieve the arity of this function application.}

\Method{getArguments}{ATermList}{}
{Retrieve the list of function arguments of this function application.}

\Method{getArgument}{ATerm}{int}
{Retrieve a specific function argument of this function application.}

%}}}
%{{{ The class ATermList

\subsection{The class {\tt ATermList}}

This class is used to represent lists of terms. 
It adds the following methods to the {\tt ATerm} base class:

\Method{isEmpty}{boolean}{}
{Check if we are dealing with the empty list.}

\Method{getFirst}{ATerm}{}
{Retrieve the first element of this list.}

\Method{getNext}{ATermList}{}
{Retrieve a list containing all elements except the first one.}

\Method{getLength}{int}{}
{Retrieve the length of this list.}

\Method{indexOf}{int}{ATerm el, int start}
{Retrieve the index of the first occurrence of {\tt el} after position
{\tt start}.}
\Describe{When {\tt el} does not occur after position {\tt start},
-1 is returned. When {\tt start} is negative, it is interpreted as an
offset from the end of the list.}

\Method{lastIndexOf}{int}{ATerm el, int start}
{Retrieve the index of the last occurrence of {\tt el} before position
{\tt start}.}
\Describe{When {\tt el} does not occur before position {\tt start},
-1 is returned. When {\tt start} is negative, it is interpreted as an
offset from the end of the list.}

\Method{concat}{ATermList}{ATermList rhs}
{Concatenate two lists.}

\Method{append}{ATermList}{ATerm el}
{Append one element to a list.}

\Method{elementAt}{ATerm}{int index}
{Retrieve a specific indexed element from a list.}
\Describe{When {\tt index} is larger than the number of elements
in the list, an {\tt IllegalArgumentException} is thrown.}

\Method{removeElementAt}{ATermList}{int index}
{Return a list where the element at {\tt index} is removed.}
\Describe{When {\tt index} is larger than the number of elements
in the list, a {\tt NullpointerException} is thrown.}

%}}}
%{{{ The class ATermPlaceholder

\subsection{The class {\tt ATermPlaceholder}}

This class is used to represent placeholder terms. It has only one
useful method:

\Method{getPlaceholderType}{ATerm}{}
{Retrieve the type of this placeholder.}

%}}}

%{{{ The class World

\subsection{The class {\tt World}}

This class represents a term database containing a set of
terms that is maximally shared. Normally a single applications
only uses one instance of this class. In this case, there is no
need to call any of the methods in this class, because the {\tt ATerm}
class and its subclasses provide a much cleaner interface to the
functionality offered by the {\tt World} class. In some rare cases
however, an application might need to create more than one 
{\tt World} instance. This could be the case for instance when
different Threads need to manipulate diverse terms and the overhead
of locking and unlocking the same {\tt World} object by both threads
for every term creation is too big.

A complete discussion of the {\tt World} class falls outside
the scope of this document.

%}}}

%}}}
%{{{ The ToolBus layer

\section{The ToolBus layer}

The \ATerm\ library also provides functionality needed to implement
\toolbus\ tools. This section describes this \toolbus\ layer in detail.

%{{{ Generation of tool interfaces

\subsection{Generation of tool interfaces}

The \ATerm\ library provides a program that takes a standard
\toolbus\ \emph{tifs} file, which is generated by the toolbus interpreter
when started with the {\tt -gentifs} option, and generates a
a tool interface in C for use with the \ATerm\ library.

The generated interface consists of two files, a C source file
and a C header (include) file. In the header file a number of interface
functions is declared, one for each element in the input signature of the tool.
It is up to the writer of the tool to provide an implementation for
these functions. The generated C file contains a handler function
that analyzes incoming terms from the \toolbus, and delegates to the
appropriate interface function.

%}}}
%{{{ Example

\subsection{Example}

Suppose we take the following simple \toolbus\ script {\tt "test.tb"}:

\begin{verbatim}
  tool testing is { command = "./testing" }

  process TEST is
  let
    T : testing,
    R : str
  in
    execute(testing, T?) .
    snd-do(T, f1(42)) .
    snd-eval(T, f2("hello world!")) .
    rec-value(T, result(R?)) .
    printf("result: %s\n", R)
  endlet

  toolbus(TEST)
\end{verbatim}

Using the command:
\begin{verbatim}
  {\tt toolbus -gentifs test.tb}
\end{verbatim}
we generate a file called {\tt "test.tifs"}. Using the command:
\begin{verbatim}
  {\tt tifstoc -tool testing test.tifs}\newline
\end{verbatim}
we generate the header file {\tt "testing.tif.h"} and the source
file {\tt "testing.tif.c"}.

{\tt "testing.tif.h"} looks like this:
\begin{verbatim}
  /**
   * This file is generated by tifstoc. Do not edit!
   * Generated from tifs for tool 'testing'
   * Headerfile generated at Thu Apr 22 11:37:36 1999
   */

  #ifndef _TESTING_H
  #define _TESTING_H

  #include <atb-tool.h>

  /* Prototypes for functions called from the event handler */
  void f1(int conn, int);
  ATerm f2(int conn, char *);
  void rec_terminate(int conn, ATerm);
  extern ATerm testing_handler(int conn, ATerm term);
  extern ATerm testing_checker(int conn, ATerm sigs);

  #endif
\end{verbatim}

Only the functions {\tt f1}, {\tt f2}, and {\tt rec\_terminate}
together with a simple {\tt main} function
have to be implemented to build a fully functional \toolbus\ tool.
The implementation of the functions {\tt testing\_handler} and 
{\tt testing\_checker} has been generated in the file {\tt "testing.tif.c"},
which looks like this:

\begin{verbatim}
  /**
   * This file is generated by tifstoc. Do not edit!
   * Generated from tifs for tool 'testing'
   * Implementation generated at Thu Apr 22 11:37:36 1999
   */

  #include "testing.tif.h"

  #define NR_SIG_ENTRIES  3

  static char *signature[NR_SIG_ENTRIES] = {
    "rec-terminate(<testing>,<term>)",
    "rec-eval(<testing>,f2(<str>))",
    "rec-do(<testing>,f1(<int>))",
  };

  /* Event handler for tool 'testing' */
  ATerm testing_handler(int conn, ATerm term)
  {
    ATerm in, out;
    /* We need some temporary variables during matching */
    int i0;
    char *s0;
    ATerm t0;

    if(ATmatch(term, "rec-eval(f2(<str>))", &s0)) {
      return f2(conn, s0);
    }
    if(ATmatch(term, "rec-terminate(<term>)", &t0)) {
      rec_terminate(conn, t0);
      return NULL;
    }
    if(ATmatch(term, "rec-do(f1(<int>))", &i0)) {
      f1(conn, i0);
      return NULL;
    }
    if(ATmatch(term, "rec-do(signature(<term>,<term>))", &in, &out)) {
      ATerm result = testing_checker(conn, in);
      if(!ATmatch(result, "[]"))
        ATfprintf(stderr, "warning: not in input signature:\n\t%\n\tl\n", result);
      return NULL;
    }

    ATerror("tool testing cannot handle term %t", term);
    return NULL; /* Silence the compiler */
  }

  /* Check the signature of the tool 'testing' */
  ATerm testing_checker(int conn, ATerm siglist)
  {
    return ATBcheckSignature(siglist, signature, NR_SIG_ENTRIES);
  }
\end{verbatim}

This file contains an array of signature definitions ({\tt signature}), 
the handler function ({\tt testing\_handler}), and the signature
checker ({\tt testing\_checker}). The only thing the handler does
is differentiating between the different possible input terms
coming from the \toolbus, and delegating the actual work to the
appropriate function.

As mentioned earlier, the only thing needed to implement the
actual tool, is the implementation of the three interface
functions {\tt f1}, {\tt f2}, and {\tt rec\_terminate}, and
the implementation of {\tt main} to get things going.
We will first take a look at the initialization stuff that
the {\tt main} function has to do:

\begin{verbatim}
  #include "testing.tif.h"

  int main(int argc, char *argv[])
  {
    ATerm bottomOfStack;

    ATBinit(argc, argv, &bottomOfStack);
    if(ATBconnect(NULL, NULL, -1, testing_handler) >= 0) {
      ATBeventloop();
    } else {
      fprintf(stderr, "Could not connect to the ToolBus, giving up!\n");
      return -1;
    }

    return 0;
  }
\end{verbatim}

The variable {\tt bottomOfStack} is needed by the \aterm\ library
to determine where to look for the stack. {\tt argc} and {\tt argv}
are passed unchanged to {\tt ATBinit}, so the \toolbus\ library can 
look for default values for things like the \toolbus\ socket address 
and the \toolbus\ host name.

The call to {\tt ATBconnect} connects to a running \toolbus, and
requires four arguments: a character
string representing the tool name, a character string representing
the host name of the \toolbus\ to connect to, the port number of the
\toolbus\ to connect to, and a handler function. Passing {\tt NULL},
{\tt NULL}, and {\tt -1} respectively as the tool name, the
host name, and the port number cause the defaults for these values
to be used instead.

When all goes well, the call to {\tt ATBeventloop} starts the main 
\toolbus\ eventloop and the tool will be ready to receive requests
from the \toolbus.

Now we only need the implementation of the three interface functions:
\begin{verbatim}
  void f1(int conn, int value)
  {
    printf("f1 called: %d\n", value);
  }

  ATerm f2(int conn, char *value)
  {
    return ATmake("snd-value(result(<str>))", value);
  }

  void rec_terminate(int conn, ATerm arg)
  {
    exit(0);
  }
\end{verbatim}

Note that the {\tt conn} argument identifies the \toolbus\ connection,
making it possible to distinguish which \toolbus\ made the request
when connected to more than one \toolbus\ at the same time.

%}}}
%{{{ Functions in the \toolbus\ layer

\subsection{Functions in the \toolbus\ layer}

The \toolbus\ layer offers the following functions:

\Function{ATBinit}{int}{int argc, char *argv[], ATerm *stack\_bottom}
{Initialize the \toolbus\ layer and the underlying \aterm\ library
when needed.}
\Describe{The return value indicates whether or not the \toolbus\
host could be found. {\tt 0} indicates that all is well, and {\tt -1}
indicates an error, in which case {\tt errno} is set to indicate
which error.}

\Function{ATBconnect}{int}{char *toolname, char *host, int port, ATBhandler h}
{Connect to a running \toolbus.}
\Describe{When {\tt NULL} is passed as {\tt toolname} or {\tt host}, or
{\tt -1} is passed as {\tt port}, default values are taken from {\tt argv}
passed to {\tt ATBinit}. The return value indicates whether or not the
connection succeeded. {\tt -1} means that the connection failed and a 
positive number or zero indicates a succesful connection attempt. In this
case this number is also the file descriptor of the socket connection
to the \toolbus.}

\Function{ATBdisconnect}{void}{int fd}
{Disconnect a from a \toolbus.}
\Describe{This function can be used to terminate a connection that
has been established earlier using {\tt ATBconnect}}

\Function{ATBeventloop}{int}{void}
{Start the tool event loop, reading and handling terms until
a connection is broken.}
\Describe{This function will not return unless something goes wrong!}

\Function{ATBwriteTerm}{int}{int fd, ATerm term}
{Send a term to the \toolbus.}
\Describe{A term is send using the \toolbus\ connection indicated by
{\tt fd}. This function is typicall used to generate \toolbus\
events, for instance:

{\tt ATBwriteTerm(fd, ATparse("snd-event(some-event)"));}
When something goes wrong, {\tt -1} is returned, otherwise {\tt 0} is
returned.}

\subsection{Control flow without the {\tt ATBeventloop}}
In some situations, the {\tt ATBeventloop} function does not offer
the right flow of control for a specific application. In this case,
the following set of functions can be used to create custom control
flow patterns:

\Function{ATBpeekOne}{ATbool}{int fd}
{Check if there is input waiting on a \toolbus\ connection}
\Describe{When there is input waiting on the specified connection,
{\tt ATtrue} is returned. Otherwise, {\tt ATfalse} is returned.}

\Function{ATBpeekAny}{int}{}
{Check if there is input waiting on any \toolbus\ connection}
\Describe{When there is input waiting on one of the \toolbus\ 
connections, the appropriate file-descriptor is returned. Otherwise,
{\tt -1} is returned. This function provides for some 'fairness' by
using a round-robin scheme in traversing the connections between
calls.}

\Function{ATBreadTerm}{ATerm}{int fd}
{Read a term from a \toolbus\ connection.}

\Function{ATBhandleOne}{int}{int fd}
{Read one term from a \toolbus\ connection, and call the 
appropriate handler. {\tt -1} is returned when something goes wrong.}

\Function{ATBhandleAny}{int}{}
{Read a single term from any \toolbus\ connection and call
the appropriate handler. {\tt -1} is returned when something
goes wrong.}

\Function{ATBgetDescriptors}{int}{fd\_set *set}
{Gather all \toolbus\ connection file descriptor in a single
descriptor set. The return value indicates the maximum
value of any descriptor in the set.}

Note that the standard {\tt ATBeventloop} can be expressed using
the following code:
\begin{verbatim}
  int ATBeventloop(void)
  {
    int fd;
    while(ATtrue) {
      fd = ATBhandleAny();
      if(fd < 0)
        return -1;
    }
  }
\end{verbatim}

%}}}

%}}}

\end{document}
