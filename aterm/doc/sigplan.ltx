\documentclass[a4paper]{article}

%{{{ LaTeX configuration

\usepackage[english]{babel}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{verbatim}

\newcommand{\ATerm}{ATerm}
\newcommand{\ATerms}{ATerms}
\newcommand{\AFun}{AFun}
\newcommand{\AFuns}{AFuns}
\def\aterms{\mbox{ATerms}}
\def\aterm{\mbox{ATerm}}
\def\appl{\mbox{ATermAppl}}
\def\atlist{\mbox{ATermList}}
\def\C{\texttt{C}}
\def\gcc{\mbox{gcc}}

%}}}

% {{{  Title definition

\title{
  Compiler Optimization Effects on the\\
  ATerm Garbage Collector\\
  $Revision$
}

\author{
  M.G.J. van den Brand$^{^1}$\\
  H.A. de Jong$^{^1}$\\
  P.A. Olivier$^{^1}$\\
  \vspace{.1cm}\\
  {\small\sl $^1$CWI,
  Department of Software Engineering\vspace{-.2cm}}\\
  {\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}
}

% }}}

\begin{document}
\maketitle

% {{{  Abstract

\begin{abstract}

\ATerm\ (short for Annotated Term) is an abstract data type designed
for the exchange of tree-like data structures between distributed
applications. The \texttt{C}-implementation of \ATerms\ is a library
based on maximal subterm sharing and automatic garbage collection.
This paper shows how a compilation technique called \emph{strength
reduction} killed the conservative garbage collector used in this
\C-library. We show how inspecting the generated assembly
helped point out a flaw in the assumptions upon which the conservative
garbage collector implementation was based, and how we repaired the
collector. Finally, we point out that other, even more ``intelligent''
optimizations could still fool our repaired collector.

\end{abstract}

% }}}

% {{{  \section{Introduction}

\label{section:intro}
\section{Introduction}

In order to fully appreciate the subtleties involved and the intricacy of
the compiled assembly statements, we first introduce the garbage collector
in Section~\ref{section:collector}. Section~\ref{section:encoding}
explains the in-memory encoding of \aterms\ in general and of the function
application (\appl) in particular. A detailed description of \aterms\
can be found in~\cite{bjko2000}.

% }}}

% {{{  \section{ATerm Garbage Collector}

\section{ATerm Garbage Collector}
\label{section:collector}

The garbage collector used in the \C\ implementation of the \aterms\ is a
so called \emph{mark-sweep} collector. Every object (\aterm) contains a
single bit used by the mark-sweep algorithm to indicate `live' (marked)
objects. At the start of a garbage collection cycle, all objects are
unmarked. The garbage collector tries to locate and mark all live objects
by traversing all terms that are explicitly protected by the programmer
(using the \texttt{ATprotect} API-call), and by scanning the \C\ run-time
stack looking for words that \emph{could} be references to objects. When
such a word is found, the object (as well as the transitive closure of
all objects it refers to) are marked as `live'.

This scan of the run-time stack causes all objects referenced from local
variables to be protected from being garbage collected. Our garbage
collector is a \emph{conservative} collector in the sense that some of
the words on the stack could accidentally have the same bit pattern as
object references. Because there is no way to distinguish these `fake'
bit patterns from `real' object references, this can cause objects to
be marked as `live' when they are actually garbage. Bit patterns on the
stack that do not \emph{point to valid objects} are not traversed at all.
Only when a bit pattern represents an address that is a valid object
address, it is followed to mark the corresponding object.

After all live objects are marked, a single sweep through the heap is
used to store all objects that are free in separate lists of free objects.

% }}}
% {{{  \section{ATerm Memory Encoding}

\section{ATerm Memory Encoding}
\label{section:encoding}

An important issue in the implementation of \aterms\ is how to represent
this data type so that all operations can be performed efficiently in
time and space.

\begin{figure}[tb]
  \centerline{\epsfig{file=header.eps,scale=0.6}}
  \caption{\label{header}The header layout}
\end{figure}

The in-memory encoding of \aterms\ we use is as follows. Assume that
one machine word consists of four bytes. Every \aterm\ object is
stored in two or more machine words. The first byte of the first word
is called the \emph{header} of the object, and consists of four fields
(see~\ref{header}).

\begin{itemize}
\item A field consisting of one bit used as a mark flag by the garbage
      collector.
\item A field consisting of one bit indicating whether or not this term
      has an annotation.
\item A field consisting of three bits that indicate the type of the term.
\item A field consisting of three bits representing the arity (number of
      pointers to other terms) of this object. When this field
      contains the maximum value of 7, the term must be a function application
      and the actual arity can be found by retrieving the arity of the
      function symbol (see below).
\end{itemize}

Depending on the type of the node (as determined by the header byte in
the first word) the remaining bytes in the first word contain either a
function symbol, a length indication, or they are unused.

The \emph{second} word is always used for hashing, and links together all
terms in the same hash bucket.

The type of the node determines its exact layout and contents.
Figure~\ref{encoding} is an excerpt from~\cite{bjko2000} showing the
encoding of the function application (called \appl{} for short).

\begin{figure}[!htb]
  \centerline{\epsfig{file=appl-enc.eps,scale=0.6}}
  \caption{\label{encoding}Encoding of the function application (\appl).}
\end{figure}

% }}}
% {{{  \section{Into the Trenches}

\section{Into the Trenches}
\label{section:trenches}

This section shows the \gcc{}-compiler in action translating a
\C{}-function that uses \aterms\ into its corresponding assembly
statements. In particular, Figure~\ref{fig:asm-diff} shows the difference
in assembly, depending on whether or not the \emph{strength reduction}
optimization was enabled during generation. The generated statements
are in SPARC assembly language for the Solaris operating system, using
version $2.95.2$ of the \gcc\ compiler.

% {{{  \subsection{Understanding the \emph{delay slot}}

\subsection{Understanding the \emph{delay slot}}

Discussing the full richness of the SPARC Assembly Language is out
of this article's scope. However, to help understand the assembly,
we now briefly discuss the notion of a \emph{delay slot}.

Branching instructions on a pipelining machine such as the SPARC are
not resolved until the decoding stage of the pipeline. When the branch
is resolved, another instruction has already been fetched. Instead of
discarding this new instruction if the branch is taken, it is executed
regardless of the branch outcome. From a sequential execution point of
view, one instruction is executed after the branch, before the branch
takes effect. This gives the appearance of the branch being delayed. Such
an instruction is said to be in the \emph{delay slot}.

In other words, keep in mind that the instruction immediately following
a branch or jump instruction is executed regardless of the branch outcome.

% }}}
% {{{  \subsection{Understanding \emph{strength reduction}}

\subsection{Understanding \emph{strength reduction}}

The compiler optimization called \emph{strength reduction} tries to
replace expensive operations such as multiplications and divisions by less
expensive additions and subtractions. Figure~\ref{fig:strength-reduction}
shows an example of a code snippet before and after applying strength
reduction. It shows how a multiplication can be eliminated from inside
a loop by performing a single addition each iteration instead.

In general, strength reduction finds \emph{induction} variables, assigns
their initial value outside (before) the loop and then updates the value
of the induction variable inside the loop using a simpler computation.

% {{{  example of strength-reduction.

\begin{figure}[!htb]
\hrulefill
\begin{footnotesize}
\begin{verbatim}
01  before strength reduction       |    after strength reduction
02                                  >    tmp = 0;
03  for (i=0; i<100; i++) {              for (i=0; i<100; i++) {
04    a[i] = j * i;                        a[i] = tmp;
05                                  >      tmp = tmp + j;
06  }                                    }
\end{verbatim}
\end{footnotesize}
  \caption{
    \label{fig:strength-reduction}
    Example of strength reduction in \texttt{diff --side-by-side} output.
  }
\end{figure}

% }}}

% }}}
% {{{  \subsection{A closeup example}

\subsection{A closeup example}

The sample code is a dressed down snippet of the \aterm{}-ToolBus
library. The code iterates over the arguments of an \appl{} (variable
\texttt{appl}) in \emph{reverse} order, building up an \atlist{}
(variable \texttt{list}) by invoking some arbitrary function (in this
case \texttt{ATBunpack}) on each of these arguments and inserting the
result in \texttt{list}. The variable \texttt{arity} holds the arity
of \texttt{appl}.

\begin{figure}[!htb]
\hrulefill
\begin{footnotesize}
\begin{verbatim}
01  ATermList list = ATempty;
02
03  for (i = arity; i >= 0; i--) {
04    list = ATinsert(list, ATBunpack(ATgetArgument(appl, i)));
05  }
\end{verbatim}
\end{footnotesize}
\caption{
  \label{fig:atb-tool}
  \texttt{C}-source of the snippet which was the target of strength reduction.
}
\end{figure}

% }}}

\begin{figure}[!htb]
\hrulefill
\begin{footnotesize}
\verbatiminput{asm-diff.ltx}
\end{footnotesize}
\caption{
\label{fig:asm-diff}
Assembly \emph{before} (L) and \emph{after} (R) strength reduction.
}
\end{figure}

% }}}
% {{{  \section{References}

\section{References}
\label{section:references}

\bibliographystyle{alpha}
\bibliography{thesis}

% }}}

\end{document}
