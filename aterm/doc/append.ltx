
\appendix


\section{Concrete Syntax}
\label{concrete-syntax}

A formal definition of the concrete
syntax of \ATerms\ using the syntax definition formalism {\sc Sdf} \cite{HHKR92.new}
is presented here.
Note that there is no concrete syntax defined for blobs, because 
a humanly readable representation of blobs depends on the type
of data stored in the blob.

\vspace{0.4cm}
{\NOAUTOHEADER  \input{spec/ATerm.mtx}}
\vspace{0.4cm}

%{{{ Level 2 interface

\section{Level 2 interface}
\label{level2}
The operations described in Section \ref{aterms-at-a-glance} are not sufficient for
all applications. Some applications need more control over the underlying 
implementation, or need operations that can be implemented using
level one constructs but can be expressed more concisely and implemented more
efficiently using more specialized constructs.

We have therefore designed a level 2 interface that is a strict superset of
the level 1 interface described in Section \ref{aterms-at-a-glance}. Some new datatypes
are introduced, as well as some new operations on \ATerms.

The level 2 interface introduces 7 new datatypes.  Except for the
auxiliary datatype \AFun\ for representing function symbols, they are
subtypes of the \ATerm\ datatype, and implement the different term
types.  These subtypes allow us to introduce operations that are only
valid for one specific term type, instead of the general \ATerm\
operations described earlier.

%{{{ ATermInt

\paragraph{ATermInt:} This datatype represents integer terms.
The operations on ATermInt are:

\begin{itemize}
\item {\tt ATermInt ATmakeInt(Integer \emph{value})}: Construct a new integer
term.
\item {\tt Integer ATgetInt(ATermInt \emph{i})}: Retrieve the value of an 
      integer term.
\end{itemize}

%}}}

%{{{ ATermReal

\paragraph{ATermReal:} This datatype represents real-number terms.
The operations on ATermReal are:

\begin{itemize}
\item {\tt ATermReal ATmakeReal(Real \emph{value})}: Construct a new 
      real term.
\item {\tt Real ATgetReal(ATermReal \emph{r})}: Retrieve the value of 
      a real term.
\end{itemize}

%}}}

%{{{ AFun

\paragraph{\AFun:} An \AFun\ consists of a string defining the function
name, an arity, and an indication whether the symbol name is quoted or not.
The operations on symbols are:
\begin{itemize}
\item {\tt AFun ATmakeAFun(String \emph{name}, Integer \emph{arity}, Boolean \emph{quoted})}: Construct
a new symbol. If a symbol with the given name, arity, and quotation already 
exists, the existing symbol is returned. Otherwise a new symbol is created
and returned. \AFuns\ are also subject to garbage collection in order
to avoid long running (interactive) programs from slowly running out of
symbols.
\item {\tt String ATgetName(AFun \emph{symbol})}: Retrieve the name of a symbol.
\item {\tt Integer ATgetArity(AFun \emph{symbol})}: Retrieve the arity of a symbol.
\item {\tt Boolean ATisQuoted(AFun \emph{symbol})}: Check if a symbol is quoted.
\end{itemize}

%}}}
%{{{ ATermAppl

\paragraph{ATermAppl:} This datatype represents function applications
consisting of a function symbol and a number of arguments.
The operations on this datatype are:
\begin{itemize}
\item {\tt ATermAppl ATmakeAppl$n$(AFun$\!\!$ \emph{fun}, ATerm \emph{arg}$_0$,
           $\ldots$, ATerm \emph{arg}$_{n-1}$)}:
	  This is a family of operations, one for each $n$ between $0$ and $6$
	  (inclusive). These operations are used to construct a new
	  function application with the given function symbol and 
	  arguments.
\item {\tt ATermAppl ATmakeAppl(AFun \emph{fun}, ATermList \emph{args})}:
		Construct a new function application with the given function
		symbol and a list of arguments.
\item {\tt AFun ATgetFun(ATermAppl \emph{appl})}: 
      Retrieve the function symbol of a function application.
\item {\tt ATerm ATgetArgument(ATermAppl \emph{appl}, Integer \emph{n})}: 
      Retrieve a specific argument.
\end{itemize}

%}}}
%{{{ ATermList

\paragraph{ATermList:} This datatype represents the binary list constructor.
Element indices start at 0. Thus a list of length $n$ has elements
$0,\ldots,n-1$.
The operations on ATermList are:
\begin{itemize}
\item {\tt ATermList ATmakeList$n$(ATerm \emph{el}$_0$$,\ldots,$
	       ATerm \emph{el}$_{n-1}$)}:
      This is a family of operations, one for each $n$ between
      $0$ and $6$ (inclusive). These operations are used to quickly construct
	  small lists of terms.
\item {\tt Integer ATgetLength(ATermList \emph{list})}: Retrieve the length of
		\emph{list}.
\item {\tt ATerm ATgetFirst(ATermList \emph{list})}: Retrieve the first element of
	\emph{list}.
\item {\tt ATermList ATgetNext(ATermList \emph{list})}: Retrieve all but the first
	element of \emph{list}.
\item {\tt ATermList ATgetPrefix(ATermList \emph{list})}: Retrieve all but the last
	element of \emph{list}.
\item {\tt ATerm ATgetLast(ATermList \emph{list})}: Retrieve the last element from
      \emph{list}.
\item {\tt ATermList ATgetSlice(ATermList \emph{list}, Integer \emph{start},
   Integer \emph{end})}: Retrieve the portion of \emph{list} from position
   \emph{start} through \emph{end-1}. 
\item {\tt Boolean ATisEmpty(ATermList \emph{list})}: Check if \emph{list}
	contains zero elements.
\item {\tt ATermList ATinsert(ATermList \emph{list}, ATerm \emph{el})}:
      Insert a single element at the start of a list.
\item {\tt ATermList ATinsertAt(ATermList \emph{list}, ATerm \emph{el},
       Integer \emph{index})}:
      Insert a single element at position index in \emph{list}.
\item {\tt ATermList ATappend(ATermList \emph{list}, ATerm \emph{el})}:
      Append a single element to the end of \emph{list}.
\item {\tt ATermList ATconcat(ATermList \emph{list1}, ATermList \emph{list2})}:
      Concatenate \emph{list1} and \emph{list2}.
\item {\tt Integer ATindexOf(ATermList \emph{list}, ATerm \emph{el},
       Integer \emph{n})}:
      Search for an element in \emph{list} and return the index of the first
      location where \emph{el} is present. Start searching at index \emph{n}.
      If the element is not present after element \emph{n}, return $-1$.
\item {\tt Integer ATlastIndexOf(ATermList \emph{list}, ATerm \emph{el},
       Integer \emph{n})}:
      Search backwards for \emph{el} in \emph{list}, and return the index of
	  the last location where the element is present. Start searching 
	at index \emph{n}. 
	If the element is not present before element \emph{n}, return $-1$.
\item {\tt ATerm ATelementAt(ATermList \emph{list}, Integer \emph{index})}:
      Retrieve element at position \emph{index} from \emph{list}.
\item {\tt ATermList ATremoveElement(ATermList \emph{list}, ATerm \emph{elem})}:
	Remove once occurrence of an element from a list.
\item {\tt ATermList ATremoveElementAt(ATermList \emph{list}, 
	Integer \emph{index})}: Remove an indexed element from a list.
\end{itemize}

%}}}

%{{{ ATermPlaceholder

\paragraph{ATermPlaceholder:} This datatype represents placeholder terms.
The operations on ATermPlaceholder are:

\begin{itemize}
\item {\tt ATermPlaceholder ATmakePlaceholder(ATerm \emph{type})}: 
      Construct a new placeholder term.
\item {\tt ATerm ATgetPlaceholder(ATermPlaceholder \emph{placeholder})}: 
      Retrieve the type of this placeholder.
\end{itemize}

%}}}
%{{{ ATermBlob

\paragraph{ATermBlob:} This datatype represents Binary Large OBject terms.
%%Blobs are never allocated, freed, or even touched by the
%%\ATerm\ library. 
%%Blob destructors can be registered using the
%%{\tt registerBlobDestructor} function. All registered destructors are
%%called before the space occupied by a `dead' ATermBlob is reused. 
The operations on ATermBlob are:

\begin{itemize}
\item {\tt ATermBlob ATmakeBlob(Integer \emph{size}, Data \emph{data})}: 
      Construct a new blob term.
\item {\tt Integer ATgetBlobSize(ATermBlob \emph{blob})}: Retrieve the size of
      a blob.
\item {\tt Data ATgetBlobData(ATermBlob \emph{blob})}: Retrieve the data
      pointer stored in a blob.
\end{itemize}

The memory management of blobs must be done explicitly by the application
programmer. 


\paragraph{Auxilary:} The level two interface provides functionality
to create and manipulate user-defined hash tables.

%}}}

%}}}

