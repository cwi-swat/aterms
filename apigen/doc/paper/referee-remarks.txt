[Referee 1]

Because we felt that for a Special Issue on ATerms, this paper should
be self-contained, we decided to put in several examples of ATerms,
AsFix and SDF. This obviously leads to a more lengthy (perhaps even
somewhat boring) paper. Because it is harder for unfamiliar readers to
find examples that are not in a paper, than it is for familiar readers
to skip them, we have decided to leave them in.


minor comments:
===============
 - the abstract should be shortened and made more self-contained

We have rewritten the abstract to a single paragraph.


 - the authors should take care to avoid colloquialisms such as
 "spectacular elimination", "why on earth", "works like a charm", etc.

These and several other colloquialisms have been removed / rewritten.


 - I would recommend moving the related work to the end of the paper,
 so you can get to your own contributions sooner.

We have decided to leave the related work section at the beginning to
position the paper right away.


 - page 9: is "true" a sort? I would think it's a constant or literal.

Referee's observation is correct, we have corrected this section.


 - please try to be more explicit in the description of examples. For
 instance, it would help to say that "Anthony" is substituted in the
 place of <str> in the example on page 11. Similarly, please explain
 the constants 1 and 0 in the example on p.12

Both substitutions are now explicitly addressed.


 - to some extent the need for this work is an artifact of the fact
 that you're communicating untyped terms between components. Would it
 be possible to communicate typed components so that a type checker
 could ensure that type violations don't take place?

We have now addressed this issue in the last paragraph of the Conclusions
section.

---------------------------------------------------------------------------

[Referee 2]

 - The term "maximal subterm sharing" appears on several pages (e.g. 3,
 4, 9) and should be shortly explained for readers not familiar with them.

The first occurence of "maximal subterm sharing" has been annotated
(footnote) with a brief explanation.


 - In the short overview of the paper (in the introduction) authors
 skiped explanation for sections 4, 5 and 7. This is really uncommon
 and have to be corrected. Moreover, a reader might get impression that
 these sections are not important at all.

This has been remedied by adding an explanation for all missing sections.


 - The reference [BSVV02] to "scannerless generalized LR parsing"
 (SGLR) should be cited when the term SGLR is mentioned on first time
 (on page 6).

The citation has been moved as suggested.


 - It seems to me that the statement on page 9 "The result of a successful
 parse is a parse tree." is not accurate enough, because authors are
 using SGRL parsing where result can be parse forest.

Referee's observation is correct: the result is a forest, not a tree.
Although we concentrate on trees in the rest of the paper, this was
confusing, so we have corrected the erroneous statement.


 - On several places (e.g. page 9) authors used terms left-hand
 (right-hand) side (of the production). Since SDF formalism change the
 order of LHS and RHS of usual BNF notation it is not clear enough if
 authors mean LHS (RHS) of usual BNF notation or SDF.

A footnote clarifying this has been added near the first figure that
shows SDF.


 - The reference to fig. 2 should be provided also with the following
 statement on page 16 "Our boolean syntax has five alternatives: true,
 false, not, and, or."

The reference has been added.


 - For naming nonterminals and alternatives authors suggest to use SDF
 labeling mechanism and "cons" annotations. However, these features are
 optionaly and not obligatory in SDF. How you get descriptive names for
 nonterminals and alternatives if grammar writer does not  label each
 nonterminal nor use "cons" annotations? Moreover, SDF for ATerms and
 AsFix (provided in appendix A and B) also do not use these features.

We feel this issue is addressed in the section "Deriving the ADT from
a SDF specification". We explain that rather than implementing several
heuristics to come up with a naming scheme, we depend heavily on the
presence of annotations.  The observation that these are not obligatory
in SDF is correct, and as a consequence, we are unable to handle grammars
which do not use this optional feature. In the actual implementation
we have experimented with some "sensible" defaults (e.g. for unlabeled
literals, we can re-use the literal), but we emphasize that to generate
predictable, legible (function)names, we depend on annotated grammar
rules.


 - The section 5 is too short and have to be expanded. This section
 is very important for readers and somehow justify the work done. If
 the paper can not be extended due to page limitation then authors can
 shorten some lenghty explanations in sections 2, 3 and 4.

We have elaborated and improved Section 5 to better explain our
experiences in applying "apigen" to the Meta Environment.


 - In the related work authors compare their work with Grammars as
 Contract, Zephyr ASDL, (D)COM, XML data binding, Generative Programming
 and  JJForester.  Since the aim of the paper (section 3) is to show
 how the library of access functions that manipulate parse trees can
 be generated from syntax definition this work is also very related to
 [Heering2000, Henriques2002] where authors show that many language-based
 tools can be automatically generated by extracting/augmenting information
 from language definition. Authors should compare their work also with
 this research area.

Our techniques both use the meta-environment described in [Heering2000]
and improves the tools used in that very same meta-environment. So not
only are we closely related to the research area described therein,
our tools and techniques *are* exactly those mentioned. A reference to
[Heering2000] has been added to the Related Work section to reflect this.

We do not feel that [Henriques2002] is closely related enough to the
generation of an API (and implementation) on a data structure as described
in our paper to explicitly compare their work. There is more work that
is related in one way or another, so we decided to mention only those
we felt are most closely related.


 - The citation [EFB01] for Aspect Oriented Programming (AOP) seems
 to me is unfair for AOP inventors. The credit have to be put to AOP
 inventors first.  Therefore, I suggest to change this reference with
 the following reference

We have updated the reference to the one suggested by the referee.


 - Typos pointed out by referee(s)

The reported typos have been fixed.
