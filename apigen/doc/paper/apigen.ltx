%
% File: apigen.ltx
%
% $Id$
%

\documentclass{article}

% {{{  packages

\usepackage{verbatim}

% }}}
% {{{  commands

\newcommand{\C}{\mbox{\sc C}}
\newcommand{\adt}{\mbox{\sc adt}}
\newcommand{\afun}{\texttt{AFun}}
\newcommand{\api}{\mbox{\sc api}}
\newcommand{\asdf}{\mbox{\sc Asf+Sdf}}
\newcommand{\asfix}{\mbox{AsFix}}
\newcommand{\asf}{\mbox{\sc Asf}}
\newcommand{\aterms}{\mbox{ATerms}}
\newcommand{\aterm}{\mbox{ATerm}}
\newcommand{\atlib}{\mbox{ATerm-Library}}
\newcommand{\autocode}{\mbox{\sc autocode}}
\newcommand{\java}{\mbox{\sc Java}}
\newcommand{\metaenv}{{\sc Asf+Sdf}\ Meta-En\-vir\-on\-ment}
\newcommand{\sdf}{\mbox{\sc Sdf}}

% }}}

% {{{  Title page

\title{Generation of Abstract Programming Interfaces from Syntax Definitions}
\author{
  H.A. de Jong$^{^1}$\\
  P.A. Olivier$^{^1}$\\
  \vspace{.1cm}\\
  {\small\sl $^1$CWI,
  Department of Software Engineering\vspace{-.2cm}}\\
  {\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}
  \vspace{.1cm}\\
  {\small\sl\tt Hayco.de.Jong@cwi.nl, Pieter.Olivierp@cwi.nl}
}

\begin{document}
\maketitle

% }}}
% {{{  Abstract

\begin{abstract}
\label{abstract}

Syntax definition languages are used to describe the syntax of a language.
Terms over these languages are parsed to produce parse trees.  These parse
trees can subsequently be processed, e.g. by a compiled specification. For
top notch performance, dedicated tools can be written in languages such as
{\tt C}. Maintainability and readability of such tools improves when they
do not operate on the tree structure directly, but rather access (parts
of) the tree using an Abstract Programming Interface~(\api). This paper
describes how a \sdf{} specification can be used to generate an abstract
\api, as well as \emph{type-safe}, \emph{efficient} implementations of
this \api{} in various programming languages.

\end{abstract}

% }}}
% {{{  Introduction


\section{Introduction}
\label{sec:intro}

Syntax definition languages such as \sdf~\cite{HHKR92} can be used
to specify the syntax of a (programming) language in a formal way. An
integrated environment such as the \metaenv~\cite{Kli93} can be used to
develop syntax definitions and specify rewrite rules. These rules can be
applied to terms which are parsed over the specified language. The view
on the language as used in the \metaenv\ is of a formal, high level
nature, which helps develop applications at the level of the (abstract)
syntax. Specifications written in this way can be compiled to a target
machine specific, executable program.

% {{{  subsection{\asdf\ in a nutshell}

\subsection{\asdf\ in a nutshell}

The specification formalism \asdf~\cite{BHK89,HHKR92} is a
combination of the algebraic specification formalism \asf\ and the
syntax definition formalism \sdf. An overview can be found in~\cite{DHK96}. 
As an illustration, Figure~\ref{fig:bool-example} presents the
definition of the Boolean datatype in \asdf.  \asdf\ specifications
consist of modules, each module has an \sdf-part (defining lexical and
context-free syntax) and an \asf-part (defining equations).  The \sdf\
part corresponds to signatures in ordinary algebraic specification
formalisms. However, syntax is not restricted to plain prefix notation
since arbitrary context-free grammars can be defined.  The syntax
defined in the \sdf-part of a module can be used immediately when
defining equations, the syntax in equations is thus \emph{user-defined}.

\begin{figure}
\hrulefill
\verbatiminput{bool.example}
\caption{\label{fig:bool-example} \asdf\ specification of the Booleans}
\hrulefill
\end{figure}

The emphasis in this chapter will be on the compilation of the equations
appearing in a specification. They have the following distinctive features:

\begin{itemize}
\item Conditional equations with positive and negative conditions.
\item Non left-linear equations.
\item List matching.
\item Default equations.
\end{itemize}

It is possible to execute specifications by interpreting the equations
as conditional rewrite rules.  The semantics of \asdf\ are based on
innermost rewriting.  Default equations are tried when all other
applicable equations have failed, because either the arguments did not
match or one of the conditions failed.

One of the powerful features of the \asdf\ specification language is
list matching.  Figure \ref{fig:set-example} shows a single equation which
removes multiple occurrences of identifiers from a set. In this
example, variables with a {\tt *} in their name are list-variables that may
match zero or more identifiers.  The implementation of list matching
may involve backtracking to find a match that satisfies the left-hand side
of the rewrite rule as well as all its conditions.
There is only backtracking within the scope of a rewrite rule, 
so if the right-hand side of the rewrite rule is normalized and this
normalization fails {\em no} backtracking is performed to find a new match.

The development of \asdf\ specifications is supported by an interactive
programming environment, the \asdf\ Meta-Environment~\cite{Kli93}.
In this environment specifications can be developed and tested.
It provides syntax-directed editors, a parser generator, and a rewrite engine.
Given this rewrite engine terms can be reduced by interpreting the equations
as rewrite rules.
For instance, the term
\begin{quote}
{\tt true \& ( false | true )}
\end{quote}
reduces to {\tt true} when applying the equations of Figure
\ref{fig:bool-example}.

\begin{figure}
\hrulefill
\verbatiminput{set.example}
\caption{\label{fig:set-example} \asdf\ specification of the Set equation}
\hrulefill
\end{figure}

% }}}
% {{{  \subsection{Annotated Terms: the \aterm\ syntax}

\subsection{Annotated Terms: the \aterm\ syntax}
\label{sec:aterm-syntax}

The definition of \aterms{} as well as its syntax in \sdf\ can be
found in~\cite{BJKO2000}. A more concise version of the syntax is
shown in figure~\ref{fig:aterm-syntax}. The definitions of the sorts
\texttt{ATermInt} and \texttt{ATermReal} describing the lexical syntax
of an integer and real valued number respectively, have been left out.
Parts of the lexical definition of a function symbol \texttt{AFun} were
likewise omitted\footnote{The official definition allows a much richer
\emph{quoted} definition for function symbols as well.}.

% {{{  fig:aterm-syntax

\begin{figure}
\hrulefill
\begin{footnotesize}
\verbatiminput{aterm.sdf}
\caption{
  \label{fig:aterm-syntax}
  Abbreviated \aterm\ syntax in \sdf.
}
\end{footnotesize}
\hrulefill
\end{figure}

% }}}

Examples of valid \aterms{} thus include:
  \texttt{42, 3.14, and(true, not(false)), rolodex(<name(String)>), [a,b,c]},
and (with annotation):
  \texttt{42\{answer\}, [a,b,c]\{chars\}, <string>\{sort\}}.

% }}}
% {{{  \subsection{\asdf\ Parse Trees: the \asfix\ syntax}

\subsection{\asdf\ Parse Trees: the \asfix\ syntax}
\label{sec:asfix-syntax}

When a term such as \texttt{true and not false} is parsed using the
\metaenv\ parser \texttt{sglr}, it yields a parse tree represented in a
format called \asfix. These parse trees are actually \aterms, preserving
lots of information about the input (such as the layout used in the input
term), as well as adding syntax-derived facts such as associativity and
constructor information to the nodes in the tree.

Without describing all of the idiosyncrasies of \asfix, the two most
important constructs used are: the grammar production (\texttt{prod}),
and its application (\texttt{appl}). We will give their \sdf\ definition
and an explanatory example:

% {{{  context-free syntax rules for "appl" and "prod"

\begin{footnotesize}
\begin{verbatim}
context-free syntax
  prod ( Symbols, Symbol, Attributes )  ->   Production
  appl ( Production, Args )             ->   Tree
\end{verbatim}
\end{footnotesize}

% }}}

\noindent The production
{\footnotesize\verb+Bool "and" Bool" -> Bool {left}+}
from Figure~\ref{fig:bool-example} looks like
this\footnote{The insertion of \texttt{cf(opt(layout))} at each
location where the input term is allowed to contain whitespace is done
automatically for each context-free syntax rule by the \sdf\ normalizer
and is left undiscussed in this paper.}:
% {{{  example "prod":  Bool "and" Bool -> Bool {left}

\begin{footnotesize}
\begin{verbatim}
  prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
    cf(sort("Bool")),
    attrs([assoc("left")]))
\end{verbatim}
\end{footnotesize}

% }}}

\noindent And the parse tree for {\footnotesize\texttt{true and false}}
becomes:
% {{{  example "appl":  true and false

\begin{footnotesize}
\begin{verbatim}
appl(
 prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
       cf(sort("Bool")),attrs([assoc("left")])),
 [appl(prod([lit("true")],cf(sort("Bool")),no-attrs),[lit("true")]),
  layout([" "]), lit("and"), layout([" "]),
  appl(prod([lit("false")],cf(sort("Bool")),no-attrs),[lit("false")])])
\end{verbatim}
\end{footnotesize}

% }}}

% }}}

% }}}
% {{{  Parse Tree access: the artisan approach

\section{Parse Tree access: the artisan approach}
\label{sec:using-atlib}

We briefly discuss the two layers of access provided by the \C\
implementation of the \atlib, and show the steps needed to gain access
to specific elements of a parse tree. Similar statements are needed in
the \java\ implementation.

% {{{  Accessing Parse Trees using the Level One interface

\subsection{Accessing Parse Trees using the Level One interface}
\label{sec:aterm-lvl1}

The level one interface offers easy to learn, but less
efficient access by using the \emph{make and match} paradigm. Terms are
constructed using \texttt{ATmake}:

% {{{  ATmake example

\begin{footnotesize}
\begin{verbatim}
  ATermAppl appl = ATmake("phone(<int>)", 5554242);
\end{verbatim}
\end{footnotesize}

% }}}

\noindent and can be inspected using \texttt{ATmatch}:

% {{{  ATmatch example

\begin{footnotesize}
\begin{verbatim}
  int number;
  ATmatch("phone(5554242)", "phone(<int>)", &number);
\end{verbatim}
\end{footnotesize}

% }}}

The \C\ code necessary to write down say, the pattern for the boolean
\texttt{true} from our running example appears more intricate already,
as we have to escape all the quotes (the \verb+"+ characters) from
interpretation by the compiler.

% {{{  Parse Tree for "true"

\begin{footnotesize}
\begin{verbatim}
 ATermAppl true = ATparse(
   "appl(prod([lit(\"true\")],cf(sort(\"Bool\")),no-attrs),[lit(\"true\")])");
\end{verbatim}
\end{footnotesize}

% }}}

As another example, consider a \C\ function that extracts the left-hand
side from a boolean conjunction. It needs to match the parse tree
of the incoming term against the pattern for the syntax production
for {\footnotesize\texttt{Bool "and" Bool -> Bool \{left\}} } with a
\texttt{<term>} placeholder at the correct spot. Because the pattern
is written as a \C\ string, we once again need to escape all quotes.
Moreover, the string representation of the match-pattern is so long
that it does not fit on one line, and we need to resort to ANSI \C\
string concatenation\footnote{Strings can be split over multiple lines by
ending lines with a \texttt{"} and starting the next line with another
\texttt{"}.} to span the
string over multiple lines.

% {{{  Level One: Extracting lhs from "true and false"

\begin{footnotesize}
\begin{verbatim}
  ATerm extract_bool_lhs(ATerm t) {
    ATerm lhs;
    char *bool_and_lhs_pattern = 
      "appl(prod([cf(sort(\"Bool\")),cf(opt(layout)),lit(\"and\"),cf(opt(layout)),"
      "cf(sort(\"Bool\"))],cf(sort(\"Bool\")),attrs([assoc(\"left\")])),[<term>],"
      "layout([\" \"]),lit(\"and\"),layout([\" \"]),appl(prod([lit(\"false\")],"
      "cf(sort(\"Bool\")),no-attrs),[lit(\"false\")])])";
  
    ATmatch(t, bool_and_lhs_pattern, &lhs);
    return lhs;
  }
\end{verbatim}
\end{footnotesize}

% }}}

% }}}
% {{{  Accessing Parse Trees using the Level Two interface

\subsection{Accessing Parse Trees using the Level Two interface}
\label{sec:aterm-lvl2}

Extracting information from an \aterm\ using \texttt{ATmatch} is
inefficient. Each time the function is invoked, the match-pattern has
to be parsed before any matching can be done. Also, if you \emph{know}
which part of the \aterm\ you need, there is really no need to build
any sort of matching automaton. Instead you can just \emph{get} the
element you are looking for. In our boolean example, if we \emph{know}
for sure that we have a valid \texttt{and}-term, we can directly extract
its left-hand side. If, however, our incoming term can be any arbitrary
\aterm, we can no longer safely extract a subterm, we have to match the
term against the pattern for an \texttt{and}-term, to see if it even
has a left-hand side.

Therefore, if we assume as a precondition to our function that it will
always be called with a valid boolean \texttt{and}-term, we can use
more direct \aterm-calls, such as \texttt{ATgetFirst} to get the head
of a list, and \texttt{ATgetArgument} to get a specific argument from
a function application.

In particular, recalling that in \asfix\ we are dealing with
\texttt{appl(prod,[args])} patterns, the \texttt{args} are always the
second argument of the \texttt{appl}. If we look closely at the \asfix\
pattern for our \texttt{and}-terms, we notice that the left-hand side
is the first element from this list of \texttt{args}. The extraction
function can now be simplified to the more efficient:

% {{{  Level Two: Extracting lhs from "true and false"

\begin{footnotesize}
\begin{verbatim}
  ATerm extract_bool_lhs(ATerm t) {
    ATermList args = ATgetArgument(t, 1);  // get arguments from AsFix "appl"
    return ATgetFirst(args);               // lhs is the first of these args.
  }
\end{verbatim}
\end{footnotesize}

% }}}

% }}}
% {{{  Maintenance issues

\subsection{Maintenance issues}
\label{sec:maintenance}

There are several fundamental maintenance issues inherent in the use
of \aterms\ as a data structure implementation in hand-crafted tools.

\begin{itemize}

\item The esoteric art of writing down multi-line, quote-escaped string
patterns and the subsequent substitution of parts of these patterns to
contain the desired placeholders at the correct locations, is so error
prone that it is almost guaranteed to go wrong somewhere. Practical
experience in the \metaenv\ has proven this many times over. Handcrafted
\aterm-patterns proliferate through numerous versions of various tools,
and after a while all sorts of ``mysterious'' bugs creep up where one tool
cannot handle the output of another tool, or simply bails out reporting
that deep down some part of an input term does not satisfy a particular
assertion. Obviously, these errors are often due to pattern mismatches,
misplaced placeholders, or ill-escaped quotes.

\item Even when the patterns are written down correctly, or if the Level
Two interface is used (which doesn't use \aterm-patterns), there is
much work to be done when the application syntax changes.

Suppose for example that the syntax of our boolean conjunction
changes from {\footnotesize\texttt{Bool "and" Bool -> Bool}} into
{\footnotesize\texttt{"and" "(" Bool, Bool ")" -> Bool}}.  Conceptually
nothing has changed: we mean exactly the same arguments when we address
them as the lhs, rhs, and result terms in both syntaxes.  However,
in the underlying parse tree the location of \emph{all three} subterms
has changed, which in turn means that all accessor functions we might
have written to work on boolean conjunction terms, must be adapted to
reflect these positional changes.

In fact, there is hardly any room for flexibility with respect to changes
in the syntax, unless the arguments happen to remain at their original
position. Every tool based on the modified \emph{application syntax}
has to be updated.

\item With such inflexibility with respect to the application syntax
in mind, imagine what would happen if the structure of the parse
trees (\asfix) \emph{itself} were to change! Every tool based on the
\emph{\asfix\ representation} of parse trees would have to be updated to
reflect the structural changes in the format. In our practical case of
the \metaenv\ where we wanted to rid \asfix\ of some legacy constructs
and in general needed to upgrade the format, this would have meant some
sort of modification to virtually \emph{every} tool in the \metaenv\
--- an arduous task indeed!

\end{itemize}

Although this article uses tools from the \metaenv\ as a running example,
the maintenance issues addressed here are not specific to parse trees
at all. The issues are fundamental to all applications that use \aterms\
as its data structure representation.

% }}}

% }}}

% {{{  From syntax to \api

\section{From syntax to \api}
\label{sec:syntax-to-api}

Abstracting from implementation details about the facts that there
is such a thing as a parse tree format and that this format in turn
is implemented using \aterms, it is easy to name several operations a
toolbuilder would like, given a \sdf\ syntax definition.

% {{{  What you want to be able to do, given an SDF definition

Typical things a toolbuilder would like to have, given our boolean
syntax are:

\begin{itemize}

\item A type definition for booleans (it is better to have a type
      \texttt{Bool} than to use the generic \texttt{ATerm} type);

\item Create the basic booleans: \texttt{true}, and \texttt{false};

\item Create a compound boolean term using basic and other compound boolean terms;

\item Given an arbitrary term, ask: \emph{is this a valid boolean term?}

\item Given an arbitrary boolean term, distinguish between a basic term
      and a compound term, e.g. by asking: \emph{Does this boolean have
      a left-hand side?}

\item Give me the right-hand side of this boolean term;

\item Replace the left-hand side of a compound boolean term by another
      boolean term.

\end{itemize}

% }}}

Fortunately, this wishlist is not at all utopian. All the information
necessary to generate an \api, and (much more important) an actual
\emph{implementation} of such an \api, is present in the \sdf-definition.

Because we want to generate code in a variety of target languages, we
opted for a ``frontend-backend'' approach. First the necessary information
is extracted from an \sdf\ specification into a proprietary intermediate
format (frontend), which is then be re-used in several code-generation
phases (backend).

The intermediate format is called \emph{annotated data type}, or \adt\
for short. It holds the minimal amount of information for each syntax
rule in the original \sdf\ specification. In particular, for each rule
we need:

% {{{  The necessary elements of an adt-entry

\begin{itemize}

\item The \emph{sortname} of the production. In our boolean syntax this
is \texttt{Bool};

\item The \emph{alternative} of the production. Our boolean syntax
has five alternatives: \texttt{true}, \texttt{false}, \texttt{not},
\texttt{and}, \texttt{or}.

\item The actual \aterm-\emph{pattern} representation of the rule.
In this pattern, each \emph{field} (non-terminal in the syntax rule)
is replaced by a typed placeholder containing the \emph{sort} of the
non-terminal and a \emph{descriptive name}. For the \texttt{and} rule
we could use \texttt{lhs}, and \texttt{rhs}, both of type \texttt{Bool}.

\end{itemize}

% }}}
% {{{  Example adt-entry with explanation

In the example of the boolean conjunction, we know that the sortname of
the production is \texttt{Bool}, the alternative is called \texttt{and}.
There are two operands, \texttt{lhs} and \texttt{rhs}, both of type
Bool.  In the pattern we put typed placeholders \texttt{<lhs(Bool)>}
and \texttt{<rhs(Bool)>} at the location of the nonterminals. Also,
because the \aterm\ pattern is a parse tree pattern, we have to deal
with any whitespace (layout) that might occur in the terms. Layout can
occur both after the non-terminal \texttt{lhs}, and after the literal
\texttt{and}. The \adt\ entry thus becomes:

\begin{scriptsize}
\begin{verbatim}
 1  [Bool,
 2   and,
 3   appl(prod(
 4    [cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
 5     cf(sort("Bool")),attrs([assoc(left)])),
 6    [<lhs(Bool)>,<ws-after-lhs(Layout)>,lit("and"),<ws-after-and(Layout)>,
 7     <rhs(Bool)>])]
\end{verbatim}
\end{scriptsize}

The sortname is in line $1$, the alternative is seen in line
$2$. Following, in lines $4-7$ is the \aterm\ pattern of the actual
parse tree. Lines $3-5$ spell out the \texttt{prod} of the \asfix\
function application.  Lines $7-8$ show the \texttt{args} part. Clearly
visible are the typed placeholders for \texttt{lhs} and \texttt{rhs},
as well as the two placeholders matching optional layout. We gave them
somewhat arbitrary names \texttt{ws-after-lhs}, and \texttt{ws-after-and}
respectively.

% }}}

% }}}

% {{{  Deriving the \adt\ from a \sdf\ specification

\section{Deriving the \adt\ from a \sdf\ specification}
\label{sec:sdf-to-adt}

Now that we know what information we would like to have, how do we get
it from the \sdf\ definition? If we look back at our \sdf\ definition
of the booleans, we can derive some of the information already. The
result \emph{sort} of a syntax rule is easy: it is explicitly mentioned
at the end of each rule. The \aterm\ pattern is relatively easy, as we
know the \sdf\ normalization rules and the underlying \asfix\ format that
is used in the \metaenv. We can follow the same rules to find the \aterm\
pattern that represents the syntax rule in actual parse trees.

But what about the \emph{alternative} and the \emph{descriptive} names
for the non-terminals that we need? Given our \sdf\ rule for the boolean
\texttt{and}, can we derive a sensible name for each of the \texttt{Bool}
non-terminals? The only information we have is in our syntax rule:
{\small\texttt{Bool "and" Bool -> Bool \{left\}} }


If we use heuristics to call them e.g. \texttt{lhs} and \texttt{rhs},
what do we do when we find another syntax rule that has three, four or
even more arguments? In syntax rules with only one non-terminal, we could
default to using the sort name of that non-terminal. But in general,
it is hard to come up with any kind of descriptive naming scheme.
Keep in mind that most toolbuilders will not really be happy if they
are confronted with access functions that have arbitrary generated
names, or numbered arguments. Instead of coming up with any heuristic,
we use the \emph{labeling} mechanism present in \sdf, to label each
non-terminal. This eliminates the need to invent a descriptive name
altogether. Our syntax rule for \texttt{and} becomes:
{\small \texttt{lhs:Bool "and" rhs:Bool -> Bool \{left\}} }

Similarly, we need a solution for the \emph{alternative} name. In this
case the literal \texttt{and} is exactly the name we want. But what
if there is no literal at all? Or what if the literal is some sort of
baroque lexical expression (think of the \C\ and \java\ symbols \verb+&&+
for conjunction). Again we are saved by \sdf, as it provides a way to
annotate syntax rules. In fact, we will re-use the annotation which is
quite commonly used in \sdf\ syntax files to annotate the name of the
\emph{abstract syntax} node that corresponds to this particular syntax
rule. Traditionally the \texttt{cons} annotation is used for this purpose.
So, finally our \texttt{and} syntax rule becomes:
{\small {\texttt{lhs:Bool "and" rhs:Bool -> Bool \{left, cons("and")\}} }

% }}}
% {{{  Code generation from \adt\ to \C

\section{Code generation from \adt\ to \C}
\label{sec:adt-to-c}

\subsection{Generated types and functions}
For each sortname in an \adt, we generate:
% {{{  Generated items

\begin{itemize}

\item An opaque type definition to distinguish instances of this
      particular sort from other \aterms.

\item Conversion functions \texttt{fromTerm} and \texttt{toTerm}
      to interface with generic \atlib-functions, such as
      \texttt{ATreadFromFile}. These functions perform a type cast,
      and as such form the entry and exit points to type safety.

\item A validity function to test whether an instance of a sort
      is indeed valid, i.e. that it indeed matches one of the
      \aterm-patterns defined as an alternative of this sort. This is
      useful to assert the validity of an externally acquired instance
      of this sort, e.g. if it has just been read from file.

\item Constructor functions for each possible alternative for this
      sort to create instances from scratch.

\item An equality function to test equality with another instance of
      this sort.

\item For each alternative of the sort, an \texttt{isAlternative} function
      that checks if the current object is an instance of that particular
      alternative.

\item For each field used in any of the alternatives of the sort,
      a \texttt{hasField} function that checks if the current object is
      an instance of an alternative that has that non-terminal.

\item Similarly, a \texttt{getField} and \texttt{setField} method for
      each of the fields in a sort.

\end{itemize}

% }}}

\subsection{Implementation}

In order to isolate the \aterm-patterns as much as possible from
the actual code, we generate a separate \C\ file for them. This
\emph{dictionary} file declares a separate \afun\ variable for each
\aterm\ function symbol, as well as a separate \aterm\ variable for each
possible pattern. An initialization function is also generated which
takes care of the proper initialization of all these variables, and
which protects them from garbage collection by the built-in collector.
A verbatim dump of all the patterns is included in a comment section in
the generated code, to provide debugging feedback when necessary.

The actual implementation of the \api\ functions is generated in its own
\C\ file, accompanied by a header file containing the signatures of all
exported \api\ functions.

% {{{  fig:Bool.c

\begin{figure}
\hrulefill
\begin{scriptsize}
\begin{verbatim}
  typedef struct _Bool *Bool;                  // opaque type
 
  Bool  BoolFromTerm(ATerm t);                 // conversion functions
  ATerm BoolToTerm(Bool arg);
 
  ATbool isEqualBool(Bool arg0, Bool arg1);    // equality function
 
  ATbool isValidBool(Bool arg);                // validity test
 
  ATbool isBoolTrue(Bool arg);                 // inspectors
  ATbool isBoolOr(Bool arg);
  ...
  ATbool hasBoolLhs(Bool arg);                 // query accessors
  ATbool hasBoolRhs(Bool arg);
  ..
  Bool getBoolLhs(Bool arg);                   // get/set accessors
  Bool setBoolLhs(Bool arg, Bool lhs);
\end{verbatim}
\caption{
  \label{fig:Bool.c}
  Part of the generated \C\ code \texttt{Bool.c}
}
\end{scriptsize}
\hrulefill
\end{figure}

% }}}

% }}}

% {{{  Bibliography

\bibliographystyle{alpha}
\bibliography{apigen}

% }}}

\end{document}
