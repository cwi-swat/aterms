%
% File: apigen.ltx
%
% $Id$
%

\documentclass{article}

% {{{  packages

\usepackage{verbatim}

% }}}
% {{{  commands

\newcommand{\aterm}{\mbox{ATerm}}
\newcommand{\aterms}{\mbox{ATerms}}
\newcommand{\atlib}{\mbox{ATerm-Library}}

\newcommand{\asfix}{\mbox{AsFix}}

\newcommand{\sdf}{\mbox{\sc Sdf}}
\newcommand{\asf}{\mbox{\sc Asf}}
\newcommand{\asdf}{\mbox{\sc Asf+Sdf}}
\newcommand{\metaenv}{{\sc Asf+Sdf}\ Meta-En\-vir\-on\-ment}
\newcommand{\api}{\mbox{\sc api}}

\newcommand{\C}{\mbox{\sc C}}
\newcommand{\java}{\mbox{\sc Java}}
\newcommand{\autocode}{\mbox{\sc autocode}}

% }}}

% {{{  Title page

\title{Generation of Abstract Programming Interfaces from Syntax Definitions}
\author{
  H.A. de Jong$^{^1}$\\
  P.A. Olivier$^{^1}$\\
  \vspace{.1cm}\\
  {\small\sl $^1$CWI,
  Department of Software Engineering\vspace{-.2cm}}\\
  {\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}
  \vspace{.1cm}\\
  {\small\sl\tt Hayco.de.Jong@cwi.nl, Pieter.Olivierp@cwi.nl}
}

\begin{document}
\maketitle

% }}}
% {{{  Abstract

\begin{abstract}
\label{abstract}

Syntax definition languages are used to describe the syntax of a language.
Terms over these languages are parsed to produce parse trees.  These parse
trees can subsequently be processed, e.g. by a compiled specification. For
top notch performance, dedicated tools can be written in languages such as
{\tt C}. Maintainability and readability of such tools improves when they
do not operate on the tree structure directly, but rather access (parts
of) the tree using an Abstract Programming Interface~(\api). This paper
describes how a \sdf{} specification can be used to generate an abstract
\api, as well as \emph{type-safe}, \emph{efficient} implementations of
this \api{} in various programming languages.

\end{abstract}

% }}}
% {{{  Introduction

\section{Introduction}
\label{sec:intro}

Syntax definition languages such as \sdf~\cite{HHKR92} can be used
to specify the syntax of a (programming) language in a formal way. An
integrated environment such as the \metaenv~\cite{Kli93} can be used to
develop syntax definitions and specify rewrite rules. These rules can be
applied to terms which are parsed over the specified language. The view
on the language as used in the \metaenv\ is of a formal, high level
nature, which helps develop applications at the level of the (abstract)
syntax. Specifications written in this way can be compiled to a target
machine specific, executable program.

% {{{  \subsection{\asdf\ in a nutshell}

\subsection{\asdf\ in a nutshell}

\texttt{TODO: intro asf + intro sdf}.

Figure~\ref{fig:boolean-syntax} shows a sample syntax for the booleans,
using only the constructors \texttt{true} and \texttt{false}, a unary
operator for negation (\texttt{not}), and binary operators for conjunction
(\texttt{and}) and disjunction (\texttt{or}). We purposely leave the
discussion about operator precedence unadressed as it is of little
relevance considering our (\api\ generation) point of view.

% {{{  fig:boolean-syntax

\begin{figure}
\hrulefill
\begin{footnotesize}
\verbatiminput{bool.sdf}
\caption{
  \label{fig:boolean-syntax}
  Syntax for the booleans in \sdf.
}
\end{footnotesize}
\hrulefill
\end{figure}

% }}}

Some examples of valid boolean terms are:
  \texttt{true}, \texttt{not false}, \texttt{true and not false}.

% }}}
% {{{  \subsection{Annotated Terms: the \aterm\ syntax}

\subsection{Annotated Terms: the \aterm\ syntax}
\label{sec:aterm-syntax}

The definition of \aterms{} as well as its syntax in \sdf\ can be
found in~\cite{BJKO2000}. A more concise version of the syntax is
shown in figure~\ref{fig:aterm-syntax}. The definitions of the sorts
\texttt{ATermInt} and \texttt{ATermReal} describing the lexical syntax
of an integer and real valued number respectively, have been left out.
Parts of the lexical definition of a function symbol \texttt{AFun} were
likewise omitted\footnote{The official definition allows a much richer
\emph{quoted} definition for function symbols as well.}.

% {{{  fig:aterm-syntax

\begin{figure}
\hrulefill
\begin{footnotesize}
\verbatiminput{aterm.sdf}
\caption{
  \label{fig:aterm-syntax}
  Abbreviated \aterm\ syntax in \sdf.
}
\end{footnotesize}
\hrulefill
\end{figure}

% }}}

Examples of valid \aterms{} thus include:
  \texttt{42, 3.14, and(true, not(false)), rolodex(<name(String)>), [a,b,c]},
and (with annotation):
  \texttt{42\{answer\}, [a,b,c]\{chars\}, <string>\{sort\}}.

% }}}
% {{{  \subsection{\asdf\ Parse Trees: the \asfix\ syntax}

\subsection{\asdf\ Parse Trees: the \asfix\ syntax}
\label{sec:asfix-syntax}

When a term such as \texttt{true and not false} is parsed using the
\metaenv\ parser \texttt{sglr}, it yields a parse tree represented in a
format called \asfix. These parse trees are actually \aterms, preserving
lots of information about the input (such as the layout used in the input
term), as well as adding syntax-derived facts such as associativity and
constructor information to the nodes in the tree.

Without describing all of the idiosyncrasies of \asfix, the two most
important constructs used are: the grammar production (\texttt{prod}),
and its application (\texttt{appl}). We will give their \sdf\ definition
and an explanatory example:

% {{{  context-free syntax rules for "appl" and "prod"

\begin{footnotesize}
\begin{verbatim}
context-free syntax
  prod ( Symbols, Symbol, Attributes )  ->   Production
  appl ( Production, Args )             ->   Tree
\end{verbatim}
\end{footnotesize}

% }}}

\noindent The production
{\footnotesize\verb+Bool "and" Bool" -> Bool {left}+}
from Figure~\ref{fig:boolean-syntax} looks like
this\footnote{The insertion of \texttt{cf(opt(layout))} at each
location where the input term is allowed to contain whitespace is done
automatically for each context-free syntax rule by the \sdf\ normalizer
and is left undiscussed in this paper.}:
% {{{  example "prod":  Bool "and" Bool -> Bool {left}

\begin{footnotesize}
\begin{verbatim}
  prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
    cf(sort("Bool")),
    attrs([assoc("left")]))
\end{verbatim}
\end{footnotesize}

% }}}

\noindent And the parse tree for {\footnotesize\texttt{true and false}}
becomes:
% {{{  example "appl":  true and false

\begin{footnotesize}
\begin{verbatim}
appl(
 prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
       cf(sort("Bool")),attrs([assoc("left")])),
 [appl(prod([lit("true")],cf(sort("Bool")),no-attrs),[lit("true")]),
  layout([" "]), lit("and"), layout([" "]),
  appl(prod([lit("false")],cf(sort("Bool")),no-attrs),[lit("false")])])
\end{verbatim}
\end{footnotesize}

% }}}

% }}}

% }}}
% {{{  Parse Tree access: the artisan approach

\section{Parse Tree access: the artisan approach}
\label{sec:using-atlib}

We briefly discuss the two layers of access provided by the \C\
implementation of the \atlib, and show the steps needed to gain access
to specific elements of a parse tree. Similar statements are needed in
the \java\ implementation.

% {{{  Accessing Parse Trees using the Level One interface

\subsection{Accessing Parse Trees using the Level One interface}
\label{sec:aterm-lvl1}

The level one interface offers easy to learn, but less
efficient access by using the \emph{make and match} paradigm. Terms are
constructed using \texttt{ATmake}:

% {{{  ATmake example

\begin{footnotesize}
\begin{verbatim}
  ATermAppl appl = ATmake("phone(<int>)", 5554242);
\end{verbatim}
\end{footnotesize}

% }}}

\noindent and can be inspected using \texttt{ATmatch}:

% {{{  ATmatch example

\begin{footnotesize}
\begin{verbatim}
  int number;
  ATmatch("phone(5554242)", "phone(<int>)", &number);
\end{verbatim}
\end{footnotesize}

% }}}

The \C\ code necessary to write down say, the pattern for the boolean
\texttt{true} from our running example appears more intricate already,
as we have to escape all the quotes (the \verb+"+ characters) from
interpretation by the compiler.

% {{{  Parse Tree for "true"

\begin{footnotesize}
\begin{verbatim}
 ATermAppl true = ATparse(
   "appl(prod([lit(\"true\")],cf(sort(\"Bool\")),no-attrs),[lit(\"true\")])");
\end{verbatim}
\end{footnotesize}

% }}}

As another example, consider a \C\ function that extracts the left-hand
side from a boolean conjunction. It needs to match the parse tree
of the incoming term against the pattern for the syntax production
for {\footnotesize\texttt{Bool "and" Bool -> Bool \{left\}} } with a
\texttt{<term>} placeholder at the correct spot. Because the pattern
is written as a \C\ string, we once again need to escape all quotes.
Moreover, the string representation of the match-pattern is so long
that it does not fit on one line, and we need to resort to ANSI \C\
string concatenation\footnote{Strings can be split over multiple lines by
ending lines with a \texttt{"} and starting the next line with another
\texttt{"}.} to span the
string over multiple lines.

% {{{  Level One: Extracting lhs from "true and false"

\begin{footnotesize}
\begin{verbatim}
  ATerm extract_bool_lhs(ATerm t) {
    ATerm lhs;
    char *bool_and_lhs_pattern = 
      "appl(prod([cf(sort(\"Bool\")),cf(opt(layout)),lit(\"and\"),cf(opt(layout)),"
      "cf(sort(\"Bool\"))],cf(sort(\"Bool\")),attrs([assoc(\"left\")])),[<term>],"
      "layout([\" \"]),lit(\"and\"),layout([\" \"]),appl(prod([lit(\"false\")],"
      "cf(sort(\"Bool\")),no-attrs),[lit(\"false\")])])";
  
    ATmatch(t, bool_and_lhs_pattern, &lhs);
    return lhs;
  }
\end{verbatim}
\end{footnotesize}

% }}}

% }}}
% {{{  Accessing Parse Trees using the Level Two interface

\subsection{Accessing Parse Trees using the Level Two interface}
\label{sec:aterm-lvl2}

Extracting information from an \aterm\ using the \texttt{ATmatch} is
inefficient. Each time the function is invoked, the pattern has to be
parsed before any matching can be done. Also, if you \emph{know} which
part of the \aterm\ you need, there is really no need to build any sort
of matching automaton. Instead you can just \emph{get} the element you
are looking for. In our boolean example, if we \emph{know} for sure that
we have a valid \texttt{and}-term, we can directly extract its left-hand
side. If, however, our incoming term can be any arbitrary \aterm, we can
no longer safely extract a subterm, we have to match the term against the
pattern for an \texttt{and}-term, to see if it even has a left-hand side.

Therefore, if we assume as a precondition to our function that it will
always be called with a valid boolean \texttt{and}-term, we can use
more direct \aterm-calls, such as \texttt{ATgetFirst} to get the head
of a list, and \texttt{ATgetArgument} to get a specific argument from
a function application.

In particular, recalling that in \asfix, we are dealing with
\texttt{appl(prod, [args])} patterns, the \texttt{args} are always the
second argument of the \texttt{appl}. If we look closely at the \asfix\
pattern for our \texttt{and}-terms, we notice that the left-hand side
is the first element from this list of \texttt{args}. The extraction
function can now be simplified to the more efficient:

% {{{  Level Two: Extracting lhs from "true and false"

\begin{footnotesize}
\begin{verbatim}
  ATerm extract_bool_lhs(ATerm t) {
    ATermList args = ATgetArgument(t, 1);  // get arguments from AsFix "appl"
    return ATgetFirst(args);               // lhs is the first of these args.
  }
\end{verbatim}
\end{footnotesize}

% }}}

% }}}
% {{{  Maintenance issues

\subsection{Maintenance issues}
\label{sec:maintenance}

There are several fundamental maintenance issues inherent in using the \atlib\
to access parse trees. These issues are fundamental as long as 

\begin{itemize}

\item The esoteric art of writing down multi-line, quote-escaped string
patterns and substituting parts of these patterns into the correct
placeholders is so error prone that it is guaranteed to go wrong
somewhere. Practical experience in the \metaenv\ has proven this many
times. Handwritten \aterm-patterns proliferate through various versions of
different tools, and after a while all sorts of ``mysterious'' bugs appear
where one tool cannot handle the output of another tool, often due to some
pattern mismatch, or a typo in the escaping of one of the many quotes.

\item Even if the patterns are written down correctly, or when the Level
Two interface, which doesn't use \aterm-patterns, is used, there is much
work to be done when the original syntax changes. If our example syntax of
the boolean conjunction is changed into: {\footnotesize\texttt{"[" Bool
"and" Bool "]" -> Bool \{left\}} } then all of a sudden, the left-hand
side is \emph{not} at the same location in the parse tree anymore and we
need to adjust our extraction function, even though, conceptually, nothing
changed. All we did was put square brackets around our conjunction.

\item What happens if the representation of parse trees \emph{itself}
changes? We wanted to get rid of some legacy constructions in \asfix,
as well as be able to change it, without having to patch all our tools
every time we decided on an upgrade of the parse tree format.

\end{itemize}

These maintenance issues are not specific to the access of elements of
parse trees. They are fundamental to each application that needs access
to an \aterm\ with more information about the location of subterms than
can be expressed in general \aterm access functions. This paper will
addresses these issues from a parse tree point of view.

% }}}

% }}}

% {{{  From syntax to \api

\section{From syntax to \api}
\label{sec:syntax-to-api}

Abstracting from implementation details about the facts that there
is such a thing as a parse tree format and that this format in turn
is implemented using \aterms, it is easy to name several operations a
toolbuilder would like, given a \sdf\ syntax definition.

% {{{  What you want to be able to do, given an SDF definition

Just to name a few operations given our boolean syntax, a toolbuilder
might want to do the following:

\begin{itemize}

\item Create the basic booleans: \texttt{true}, and \texttt{false};

\item Create a compound boolean term using basic and other compound boolean terms;

\item Given an arbitrary term, ask: \emph{is this a valid boolean term?}

\item Given an arbitrary boolean term, distinguish between a basic term
      and a compound term, e.g. by asking: \emph{Does this boolean have
      a left-hand side?}

\item Give me the right-hand side of this boolean term;

\item Replace the left-hand side of a compound boolean term by another
      boolean term.

\end{itemize}

% }}}

Fortunately, this wishlist is not at all utopian. All the information
necessary to generate an \api, and (much more important) an actual
\emph{implementation} of such an \api, is present in the \sdf-definition.


% }}}

% {{{  Bibliography

\bibliographystyle{alpha}
\bibliography{apigen}

% }}}

\end{document}
