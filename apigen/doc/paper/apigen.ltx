%
% File: apigen.ltx
%
% $Id$
%

\documentclass{article}

% {{{  packages

\usepackage{verbatim}

% }}}
% {{{  commands

\newcommand{\aterm}{\mbox{ATerm}}
\newcommand{\aterms}{\mbox{ATerms}}

\newcommand{\asfix}{\mbox{AsFix}}

\newcommand{\apigen}{\mbox{\sc apigen}}
\newcommand{\sdf}{\mbox{\sc Sdf}}
\newcommand{\asf}{\mbox{\sc Asf}}
\newcommand{\asdf}{\mbox{\sc Asf+Sdf}}
\newcommand{\asmetaenv}{{\sc Asf+Sdf}\ Meta-En\-vir\-on\-ment}
\newcommand{\api}{\mbox{\sc api}}

% }}}

% {{{  Title page

\title{Generation of Abstract Programming Interfaces from Syntax Definitions}
\author{
  H.A. de Jong$^{^1}$\\
  P.A. Olivier$^{^1}$\\
  \vspace{.1cm}\\
  {\small\sl $^1$CWI,
  Department of Software Engineering\vspace{-.2cm}}\\
  {\small\sl Kruislaan 413, 1098 SJ Amsterdam, The Netherlands}
  \vspace{.1cm}\\
  {\small\sl\tt Hayco.de.Jong@cwi.nl, Pieter.Olivierp@cwi.nl}
}

\begin{document}
\maketitle

% }}}
% {{{  Abstract

\begin{abstract}

Syntax definition languages are used to describe the syntax of a language.
Terms over these languages are parsed to produce parse trees.  These parse
trees can subsequently be processed, e.g. by a compiled specification. For
top notch performance, dedicated tools can be written in languages such as
{\tt C}. Maintainability and readability of such tools improves when they
do not operate on the tree structure directly, but rather access (parts
of) the tree using an Abstract Programming Interface~(\api). This paper
describes how a \sdf{} specification can be used to generate an abstract
\api, as well as \emph{type-safe}, \emph{efficient} implementations of
this \api{} in various programming languages.

\end{abstract}

% }}}
% {{{  Introduction

\section{Introduction}\label{intro}

Syntax definition languages such as \sdf~\cite{HHKR92} can be used
to specify the syntax of a (programming) language in a formal way. An
integrated environment such as the \asmetaenv~\cite{Kli93} can be used to
develop syntax definitions and specify rewrite rules. These rules can be
applied to terms which are parsed over the specified language. The view
on the language as used in the \asmetaenv{} is of a formal, high level
nature, which helps develop applications at the level of the (abstract)
syntax. Specifications written in this way can be compiled to a target
machine specific, executable program.

% }}}

% {{{  \subsection{\asdf\ in a nutshell}

\subsection{\asdf\ in a nutshell}

\texttt{TODO: intro asf + intro sdf}.

Figure~\ref{fig:boolean-syntax} shows a sample syntax for the booleans,
using only the constructors \texttt{true} and \texttt{false}, a unary
operator for negation (\texttt{not}), and binary operators for conjunction
(\texttt{and}) and disjunction (\texttt{or}). We purposely leave the
discussion about operator precedence unadressed as it is of little
relevance considering our (\api\ generation) point of view.

% {{{  fig:boolean-syntax

\begin{figure}
\hrulefill
\begin{footnotesize}
\verbatiminput{bool.sdf}
\caption{
  \label{fig:boolean-syntax}
  Syntax for the booleans in \sdf.
}
\end{footnotesize}
\hrulefill
\end{figure}

% }}}

Some examples of valid boolean terms are:
  \texttt{true}, \texttt{not false}, \texttt{true and not false}.

% }}}
% {{{  \subsection{Annotated Terms: the \aterm\ syntax}

\subsection{Annotated Terms: the \aterm\ syntax}

The definition of \aterms{} as well as its syntax in \sdf\ can be
found in~\cite{BJKO2000}. A more concise version of the syntax is
shown in figure~\ref{fig:aterm-syntax}. The definitions of the sorts
\texttt{ATermInt} and \texttt{ATermReal} describing the lexical syntax
of an integer and real valued number respectively, have been left out.
Parts of the lexical definition of a function symbol \texttt{AFun} were
likewise omitted\footnote{The official definition allows a much richer
\emph{quoted} definition for function symbols as well.}.

% {{{  fig:aterm-syntax

\begin{figure}
\hrulefill
\begin{footnotesize}
\verbatiminput{aterm.sdf}
\caption{
  \label{fig:aterm-syntax}
  Abbreviated \aterm\ syntax in \sdf.
}
\end{footnotesize}
\hrulefill
\end{figure}

% }}}

Examples of valid \aterms{} thus include:
  \texttt{42, 3.14, and(true, not(false)), rolodex(<name(String)>), [a,b,c]},
and (with annotation):
  \texttt{42\{answer\}, [a,b,c]\{chars\}, <string>\{sort\}}.

% }}}
% {{{  \subsection{\asdf\ Parse Trees: the \asfix\ syntax}

\subsection{\asdf\ Parse Trees: the \asfix\ syntax}

When a term such as \texttt{true and not false} is parsed using the
\asmetaenv\ parser \texttt{sglr}, it yields a parse tree represented in a
format called \asfix. These parse trees are actually \aterms, preserving
lots of information about the input (such as the layout used in the input
term), as well as adding syntax-derived facts such as associativity and
constructor information to the nodes in the tree.

Without describing all of the idiosyncrasies of \asfix, the two most
important constructs used are: the grammar production (\texttt{prod}),
and its application (\texttt{appl}). We will give their \sdf\ definition
and an explanatory example:

% {{{  context-free syntax rules for "appl" and "prod"

\begin{footnotesize}
\begin{verbatim}
context-free syntax
  prod ( Symbols, Symbol, Attributes )  ->   Production
  appl ( Production, Args )             ->   Tree
\end{verbatim}
\end{footnotesize}

% }}}

\noindent The production
{\footnotesize\verb+Bool "and" Bool" -> Bool {left}+}
from Figure~\ref{fig:boolean-syntax} looks like
this\footnote{The insertion of \texttt{cf(opt(layout))} at each
location where the input term is allowed to contain whitespace is done
automatically for each context-free syntax rule by the \sdf\ normalizer
and is left undiscussed in this paper.}:
% {{{  example "prod":  Bool "and" Bool -> Bool {left}

\begin{footnotesize}
\begin{verbatim}
  prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
    cf(sort("Bool")),
    attrs([assoc("left")]))
\end{verbatim}
\end{footnotesize}

% }}}

\noindent And the parse tree for {\footnotesize\texttt{true and false}}
becomes:
% {{{  example "appl":  true and false

\begin{footnotesize}
\begin{verbatim}
appl(
 prod([cf(sort("Bool")),cf(opt(layout)),lit("and"),cf(opt(layout)),cf(sort("Bool"))],
       cf(sort("Bool")),attrs([assoc("left")])),
 [appl(prod([lit("true")],cf(sort("Bool")),no-attrs),[lit("true")]),
  layout([" "]), lit("and"), layout([" "]),
  appl(prod([lit("false")],cf(sort("Bool")),no-attrs),[lit("false")])])
\end{verbatim}
\end{footnotesize}

% }}}

% }}}

% {{{  Bibliography

\bibliographystyle{alpha}
\bibliography{apigen}

% }}}

\end{document}
