equations

[equ-sdf-to-adt-cons-expand]
  sdf-to-adt-cons-expand($SDF) = sdf-to-adt($SDF, cons-expand)

[equ-sdf-to-adt-cons-remove]
  sdf-to-adt-cons-remove($SDF) = sdf-to-adt($SDF, cons-remove)

[equ-sdf-to-adt-definition-empty]
  sdf-to-adt(definition ,$ConsOption) = [ ]

[equ-sdf-to-adt-defintion-divide]
  sdf-module-to-adt($Module, $ConsOption) = $ADT1,
  sdf-to-adt(definition $Module*, $ConsOption) = $ADT2,
  merge-adts($ADT1, $ADT2) = $ADT3
  ===>
  sdf-to-adt(definition $Module $Module*, $ConsOption) = $ADT3

[equ-sdf-to-adt-module]
  sdf-to-adt($Module, $ConsOption) = sdf-module-to-adt($Module, $ConsOption)

[equ-sdf-module-to-adt-empty]
  sdf-module-to-adt(module $ModName $ImpSection*, $ConsOption) = [ ]

[equ-sdf-module-to-adt-divide]
  section-to-adt($ModName, $Section, $ConsOption) = $Entries1,
  sdf-module-to-adt(module $ModName $ImpSection* $Section*, $ConsOption) = [ $Entries2 ]
  ===>
  sdf-module-to-adt(module $ModName $ImpSection* $Section $Section*, $ConsOption) = 
	[ $Entries1, $Entries2 ]

[equ-section-to-adt-exports]
  section-to-adt($ModName, exports $Grammar, $ConsOption) =
    grammar-to-adt($ModName, $Grammar, $ConsOption)

[equ-section-to-adt-hiddens]
  section-to-adt($ModName, hiddens $Grammar, $ConsOption) = grammar-to-adt($ModName, $Grammar, $ConsOption)

[default-grammar-to-adt]
  grammar-to-adt($ModName, $Grammar, $ConsOption) =

[equ-grammar-to-adt-divide]
  grammar-to-adt($ModName, $Grammar1, $ConsOption) = $Entries1,
  grammar-to-adt($ModName, $Grammar2, $ConsOption) = $Entries2
  ===>
  grammar-to-adt($ModName, $Grammar1 $Grammar2, $ConsOption) = $Entries1, $Entries2

[equ-grammar-to-adt-context-free-syntax]
  grammar-to-adt($ModName, context-free syntax $Production*, $ConsOption) = 
	productions-to-adt($ModName, $Production*, $ConsOption)

[equ-grammar-to-adt-lexical-syntax]
  grammar-to-adt($ModName, lexical syntax $Production*, $ConsOption) =
        lexicals-to-adt($Production*)

[equ-productions-to-adt-empty]
  productions-to-adt($ModName, , $ConsOption) =

[equ-productions-to-adt-divide]
  production-to-adt($ModName, $Production, $ConsOption) = $Entries1,
  productions-to-adt($ModName, $Production*, $ConsOption) = $Entries2
  ===>
  productions-to-adt($ModName, $Production $Production*, $ConsOption) = $Entries1, $Entries2

[equ-production-to-adt-cons]
  $Attributes = { $Attr*1, cons(at-literal(""" $Char* """)), $Attr*2 },
  $AltId   = afun($Char*),
  $TypeId  = sort-to-afun($Sort),
  $AFProd  = build-asfix-prod($ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  = build-asfix-appl-args($Symbol*),
  $Entry   = [ $TypeId, $AltId, appl($AFProd, w(""), [$AFArgs]) ],
  $Entries = build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) = $Entry, $Entries

[equ-production-to-adt-bracket]
  $Attributes = { bracket },
  $AltId   = afun("B" "r" "a" "c" "k" "e" "t"),
  $TypeId  = sort-to-afun($Sort),
  $AFProd  = build-asfix-prod($ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  = build-asfix-appl-args($Symbol*),
  $Entry   = [ $TypeId, $AltId, appl($AFProd, w(""), [$AFArgs]) ],
  $Entries = build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) = $Entry, $Entries
 
[default-production-to-adt]
  $AltId   = afun("D" "e" "f" "a" "u" "l" "t"),
  $TypeId  = sort-to-afun($Sort),
  $AFProd  = build-asfix-prod($ModName, $Symbol*, $Sort, $Attributes, $ConsOption),
  $AFArgs  = build-asfix-appl-args($Symbol*),
  $Entry   = [ $TypeId, $AltId, appl($AFProd, w(""), [$AFArgs]) ],
  $Entries = build-list-entries($Symbol*)
  ===>
  production-to-adt($ModName, $Symbol* -> $Sort $Attributes, $ConsOption) = $Entry, $Entries
 


[equ-sort-to-afun]
  sort-to-afun(sort($Char*)) = afun($Char*) 

[equ-build-asfix-prod]
  $AFModName = modname-to-lit($ModName),
  $AFArgs    = build-asfix-prod-args($Symbol*),
  $AFSort    = sort-to-lit($Sort),
  $AFAttrs   = build-asfix-attrs($Attributes, $ConsOption)
  ===>
  build-asfix-prod($ModName, $Symbol*, $Sort, $Attributes, $ConsOption) =
    prod(id($AFModName),w(""),[$AFArgs],w(""),l("->"),w(""),sort($AFSort),w(""),$AFAttrs)

[equ-modname-to-lit]
  modname-to-lit(moduleid($Char*)) = at-literal(""" $Char* """)

[equ-sort-to-lit]
  sort-to-lit(sort($Char*)) = at-literal(""" $Char* """)

[equ-sort-to-afun]
  sort-to-afun(sort($Char*)) = afun($Char*)

[equ-build-asfix-prod-args-empty]
  build-asfix-prod-args() =

[equ-build-asfix-prod-args-single]
  build-asfix-prod-args($Symbol) = build-asfix-prod-arg($Symbol)

[equ-build-asfix-prod-args-divide]
  build-asfix-prod-arg($Symbol) = $AFArg,
  build-asfix-prod-args($Symbol+) = $AFArgs
  ===>
  build-asfix-prod-args($Symbol $Symbol+) = $AFArg, w(""), $AFArgs

[equ-build-asfix-prod-arg-strip-label]
  build-asfix-prod-arg($Label : $Symbol) = build-asfix-prod-arg($Symbol)

[equ-build-asfix-prod-arg-sort]
  build-asfix-prod-arg($Sort) = sort(sort-to-lit($Sort))

[equ-build-asfix-prod-arg-qlit]
  build-asfix-prod-arg($QLit) = ql(sdflit-to-lit($QLit))

[equ-build-asfix-prod-arg-uqlit]
  build-asfix-prod-arg($UQLit) = ql(sdflit-to-lit($UQLit))

[equ-build-asfix-prod-arg-iter-star]
  build-asfix-prod-arg($Label : $Sort *) = 
	build-asfix-iter($Sort, l("*"))

[equ-build-asfix-prod-arg-iter-plus]
  build-asfix-prod-arg($Label : $Sort +) = 
	build-asfix-iter($Sort, l("+"))

[equ-build-asfix-prod-arg-iter-sep-star]
  build-asfix-prod-arg($Label : { $Sort $Sep } *) = 
	build-asfix-iter-sep($Sort, $Sep, l("*"))

[equ-build-asfix-prod-arg-iter-sep-plus]
  build-asfix-prod-arg($Label : { $Sort $Sep } +) = 
	build-asfix-iter-sep($Sort, $Sep, l("+"))

[equ-build-list-entries-empty]
  build-list-entries() =

[equ-build-list-entries-divide]
  build-list-entries($Symbol) = $Entries1,
  build-list-entries($Symbol+) = $Entries2
  ===>
  build-list-entries($Symbol $Symbol+) = $Entries1, $Entries2

[equ-build-list-entries-iter-star]
  $FieldId = sdflit-to-afun($Label),
  $ElemType = sort-to-afun($Sort),
  $ListType = afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : $Sort *) = 
     [$ListType, empty,  []],
     [$ListType, single, [<head($ElemType)>]],
     [$ListType, many,   [<head($ElemType)>,
                          w(<ws-after-first(str)>),
                          <[tail($ListType)]>]]

[equ-build-list-entries-iter-plus]
  $FieldId = sdflit-to-afun($Label),
  $ElemType = sort-to-afun($Sort),
  $ListType = afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : $Sort +) = 
     [$ListType, single, [<head($ElemType)>]],
     [$ListType, many,   [<head($ElemType)>,
                          w(<ws-after-first(str)>),
                          <[tail($ListType)]>]]

[equ-build-list-entries-iter-sep-star]
  $FieldId = sdflit-to-afun($Label),
  $ElemType = sort-to-afun($Sort),
  $ListType = afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : { $Sort $Sep } *) = 
     [$ListType, empty,[]],
     [$ListType, single, [<head($ElemType)>]],
     [$ListType, many,[<head($ElemType)>,
                       w(<ws-after-first(str)>),
                       sep(<sep(str)>),
                       w(<ws-after-sep(str)>),
                       <[tail($ListType)]>]]

[equ-build-list-entries-iter-sep-plus]
  $FieldId = sdflit-to-afun($Label),
  $ElemType = sort-to-afun($Sort),
  $ListType = afun-concat($ElemType $FieldId)
  ===>
  build-list-entries($Label : { $Sort $Sep } +) = 
     [$ListType, single, [<head($ElemType)>]],     
     [$ListType, many,[<head($ElemType)>,
                       w(<ws-after-first(str)>),
                       sep(<sep(str)>),
                       w(<ws-after-sep(str)>),
                       <[tail($ListType)]>]]

[default-equ-build-list-entries]
  build-list-entries($Symbol) =

% Unify unquoted and quoted literals, note that this is a bug in AsFix1/pgen! %
[equ-sdflit-to-lit-quoted]
  sdflit-to-lit(literal($Char*)) = at-literal($Char*)

[equ-sdflit-to-lit-unquoted]
  sdflit-to-lit(uqliteral($Char*)) = at-literal(""" $Char* """)

[equ-sdflit-to-afun-quoted]
  sdflit-to-afun(literal(""" $Char* """)) = afun($Char*)

[equ-sdflit-to-afun-unquoted]
  sdflit-to-afun(uqliteral($Char*)) = afun($Char*)

[equ-build-asfix-appl-args-empty]
  build-asfix-appl-args() =

[equ-build-asfix-appl-args-single]
  build-asfix-appl-args($Symbol) = build-asfix-appl-arg($Symbol)

[equ-build-asfix-appl-args-divide-explicit-label]
  build-asfix-appl-arg($Label:$Symbol) = $AFArg,
  build-asfix-appl-args($Symbol+) = $AFArgs,
  afun-concat(ws after sdflit-to-afun($Label)) = $FieldId,
  w(<$FieldId(str)>) = $FieldWs
  ===>
  build-asfix-appl-args($Label:$Symbol $Symbol+) = $AFArg, $FieldWs, $AFArgs

[default-build-asfix-appl-args-divide-implicit-label]
  build-asfix-appl-arg($Literal) = $AFArg,
  build-asfix-appl-args($Symbol+) = $AFArgs,
  afun-concat(ws after sdflit-to-lit($Literal)) = $FieldId,
  w(<$FieldId(str)>) = $FieldWs
  ===>
  build-asfix-appl-args($Literal $Symbol+) = $AFArg, $FieldWs, $AFArgs

[equ-build-asfix-appl-arg-labeled-literal]
  build-asfix-appl-arg($Label:$Literal) = l(sdflit-to-lit($Literal))

[equ-build-asfix-appl-arg-unlabeled-literal]
  build-asfix-appl-arg($Literal) = l(sdflit-to-lit($Literal))

[equ-build-asfix-appl-arg-sort]
  $FieldId = sdflit-to-afun($Label),
  $FieldType = sort-to-afun($Sort)
  ===>
  build-asfix-appl-arg($Label:$Sort) = <$FieldId($FieldType)>

[equ-build-asfix-appl-arg-iter-star]
  $FieldId = sdflit-to-afun($Label),
  $FieldType = afun-concat(sort-to-afun($Sort) $FieldId)
  ===>
  build-asfix-appl-arg($Label:$Sort *) = 
	list(build-asfix-iter($Sort, l("*")),w(""),<$FieldId($FieldType)>)

% Plus-list transformed into star-list because AsFix1 demands this! %
[equ-build-asfix-appl-arg-iter-plus]
  $FieldId = sdflit-to-afun($Label),
  $FieldType = afun-concat(sort-to-afun($Sort) $FieldId)
  ===>
  build-asfix-appl-arg($Label:$Sort +) = 
	list(build-asfix-iter($Sort, l("*")),w(""),<$FieldId($FieldType)>)

[equ-build-asfix-appl-arg-iter-sep-star]
  $FieldId = sdflit-to-afun($Label),
  $FieldType = afun-concat(sort-to-afun($Sort) $FieldId)
  ===>
  build-asfix-appl-arg($Label:{ $Sort $Sep }*) =
        list(build-asfix-iter-sep($Sort, $Sep, l("*")),w(""),<$FieldId($FieldType)>)

% Plus-list transformed into star-list because AsFix1 demands this! %
[equ-build-asfix-appl-arg-iter-sep-plus]
  $FieldId = sdflit-to-afun($Label),
  $FieldType = afun-concat(sort-to-afun($Sort) $FieldId)
  ===>
  build-asfix-appl-arg($Label:{ $Sort $Sep }+) = 
        list(build-asfix-iter-sep($Sort, $Sep, l("*")),w(""),<$FieldId($FieldType)>)

[equ-build-asfix-iter]
  $ElemSortName = sort-to-lit($Sort)
  ===>  
  build-asfix-iter($Sort,$AFIter) = iter(sort($ElemSortName),w(""),$AFIter)

[equ-build-asfix-iter-sep]
  $Sort = sort($Char*),
  $ElemSortName = at-literal(""" $Char* """),
  $AFSep = sdflit-to-lit($Sep)
  ===>  
  build-asfix-iter-sep($Sort, $Sep, $AFIter) = 
	iter-sep(l("{"),w(""),sort($ElemSortName),w(""),ql($AFSep),w(""),l("}"),w(""),$AFIter)

[equ-build-asfix-attrs-empty]
  build-asfix-attrs(, $ConsOption) = no-attrs

[equ-build-asfix-attrs-empty]
  build-asfix-attrs({}, $ConsOption) = no-attrs

[equ-build-asfix-attrs-not-empty-no-attrs]
  build-asfix-attr-list($Attr+, $ConsOption) = 
  ===>
  build-asfix-attrs({$Attr+}, $ConsOption) = no-attrs

[equ-build-asfix-attrs-not-empty]
  build-asfix-attr-list($Attr+, $ConsOption) = $AFAttr+
  ===>
  build-asfix-attrs({$Attr+}, $ConsOption) = 
    attrs(l("{"),w(""),[$AFAttr+],w(""),l("}"))

[equ-build-asfix-attr-list-single]
  build-asfix-attr-list($Attr, $ConsOption) = 
    build-asfix-attr($Attr, $ConsOption)

[equ-build-asfix-attr-list-divide]
  build-asfix-attr($Attr, $ConsOption) = $AFAttr+1,
  build-asfix-attr-list($Attr+, $ConsOption) = $AFAttr+2
  ===>
  build-asfix-attr-list($Attr, $Attr+, $ConsOption) =
     $AFAttr+1,w(""),sep(","),w(""),$AFAttr+2

[default-build-asfix-attr-list-divide]
  build-asfix-attr($Attr, $ConsOption) = $AFAttr*1,
  build-asfix-attr-list($Attr+, $ConsOption) = $AFAttr*2
  ===>
  build-asfix-attr-list($Attr, $Attr+, $ConsOption) = $AFAttr*1,$AFAttr*2

[equ-build-asfix-attr-left]        build-asfix-attr(left, $ConsOption)        = l("left")
[equ-build-asfix-attr-right]       build-asfix-attr(right, $ConsOption)       = l("right")
[equ-build-asfix-attr-assoc]       build-asfix-attr(assoc, $ConsOption)       = l("assoc")
[equ-build-asfix-attr-bracket]     build-asfix-attr(bracket, $ConsOption)     = l("bracket")
[equ-build-asfix-attr-constructor] build-asfix-attr(constructor, $ConsOption) = l("constructor")
[equ-build-asfix-attr-memo]        build-asfix-attr(memo, $ConsOption)        = l("memo")
[equ-build-asfix-attr-traverse]    build-asfix-attr(traverse, $ConsOption)    = l("traverse")
[equ-build-asfix-attr-avoid]       build-asfix-attr(avoid, $ConsOption)       = l("avoid")
[equ-build-asfix-attr-prefer]      build-asfix-attr(prefer, $ConsOption)      = l("prefer")

[equ-build-asfix-attr-cons-remove]
  build-asfix-attr(cons(at-literal(""" $Char* """)), cons-remove) =

[equ-build-asfix-attr-cons-expand]
  build-asfix-attr(cons($ATerm), cons-expand) = cons($ATerm)

[equ-lexicals-to-adt-empty]
  lexicals-to-adt() =

[equ-lexicals-to-adt-divide]
  lexical-to-adt($Production) = $Entries1,
  lexicals-to-adt($Production*) = $Entries2
  ===>
  lexicals-to-adt($Production $Production*) = $Entries1, $Entries2

[equ-lexical-to-adt-LAYOUT]
  lexical-to-adt($Symbol* -> LAYOUT $Attributes) =

[default-lexical-to-adt]
  $Attributes = { $Attr*1, cons(at-literal(""" $Char* """)), $Attr*2 },
  $AltId = afun($Char*),
  $TypeId = sort-to-afun($Sort),
  $AFSort = sort-to-lit($Sort)
  ===>
  lexical-to-adt($Symbol* -> $Sort $Attributes) = 
	[ $TypeId, $AltId, lex(<lex(str)>,sort($AFSort)) ]
