equations

[equ-c-api]
  c-api: $Prefix , $Prologue, $ADT = 
	gen-c-api($Prefix, $Prologue, generate-api($ADT))

[equ-gen-c-api]
  gen-header($Prefix, $Prologue, $API) = $Header,
  gen-source($Prefix, $API) = $Source,
  gen-dict($API) = $Dict
  ===>
  gen-c-api($Prefix, $Prologue, $API) =
        build-header-tag($Prefix) $Header $$
        build-source-tag($Prefix) $Source $$
        build-dict-tag($Prefix) [ afuns([]), terms([$Dict]) ] $$

[equ-gen-header]
  gen-typedefs($API) = $Typedef*,
  gen-fun-decls($API) = $FunDeclList,
  build-macro($Prefix) = $Macro,
  build-dict-header($Prefix) = $DictHeader
  ===>
  gen-header($Prefix, $Prologue, $API) = 
	#ifndef $Macro @
	#define $Macro @
        #include $DictHeader@
	$Prologue $Typedef* $FunDeclList
        extern build-init-decl($Prefix);
	#endif @

[equ-gen-typedefs-empty]
  gen-typedefs(api [ ]) =

[equ-gen-typedefs-divide]
  gen-typedef($Type)  = $Typedef,
  gen-typedefs(api [ $Type* ]) = $Typedef*
  ===>
  gen-typedefs(api [ $Type $Type* ]) = $Typedef $Typedef*

[equ-gen-typedef]
  gen-typedef(type [ $TypeId, $Alt+, $Field* ]) = build-typedef($TypeId)

[equ-gen-fun-decls-empty]
  gen-fun-decls(api [ ]) =

[equ-gen-fun-decls-divide]
  gen-term-decls($Type) = $FunDeclList1,
  gen-constructor-decls-top($Type) = $FunDeclList2,
  gen-valid-decl($Type) = $FunDeclList3,
  gen-check-decls($Type) = $FunDeclList4,
  gen-access-decls($Type) = $FunDeclList5,
  gen-fun-decls(api [ $Type* ]) = $FunDeclList6
  ===>
  gen-fun-decls(api [ $Type $Type* ]) = 
	$FunDeclList1 $FunDeclList2 $FunDeclList3 
        $FunDeclList4 $FunDeclList5 $FunDeclList6

[equ-gen-constructor-decls-top-single]
  gen-constructor-decls-top(type [ $TypeId, $Alt, $Field* ]) =
	extern gen-constructor-decl-single($TypeId, $Field*);

[default-gen-constructor-decls-top]
  gen-constructor-decls-top($Type) = gen-constructor-decls($Type)

[equ-gen-constructor-decls-single]
  gen-constructor-decls(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) = 
	extern gen-constructor-decl($TypeId, $AltId, $Field*);

[equ-gen-constructor-decls-divide]
  gen-constructor-decls(type [ $TypeId, $Alt, $Field* ]) = $FunDeclList1,
  gen-constructor-decls(type [ $TypeId, $Alt+, $Field*]) = $FunDeclList2
  ===>
  gen-constructor-decls(type [ $TypeId, $Alt $Alt+, $Field* ]) = $FunDeclList1 $FunDeclList2

[equ-gen-constructor-decl-single]
  sort-fields($Field*) = $SortedField*,
  build-formal-args-list($SortedField*) = $FormalArg*
  ===>
  gen-constructor-decl-single($TypeId, $Field*) = 
	build-c-id($TypeId) build-c-id(make $TypeId) ( $FormalArg* )

[equ-gen-constructor-decl]
  get-fields-for-alt($AltId, $Field*) = $AltField*,
  sort-fields($AltField*) = $SortedField*,
  build-formal-args-list($SortedField*) = $FormalArg*
  ===>
  gen-constructor-decl($TypeId, $AltId, $Field*) = 
	build-c-id($TypeId) build-c-id(make $TypeId $AltId) ( $FormalArg* )

[equ-gen-valid-decl]
  gen-valid-decl(type [ $TypeId, $Alt+, $Field* ]) =
    extern ATbool build-c-id(is valid $TypeId)(build-c-id($TypeId) arg);

[equ-gen-check-decls-single]
  gen-check-decls(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) =
	extern build-check-decl($TypeId, $AltId);

[equ-gen-check-decls-divide]
  gen-check-decls(type [ $TypeId, $Alt, $Field* ]) = $FunDeclList1,
  gen-check-decls(type [ $TypeId, $Alt+, $Field* ]) = $FunDeclList2
  ===>
  gen-check-decls(type [ $TypeId, $Alt $Alt+, $Field* ]) = $FunDeclList1 $FunDeclList2

[equ-gen-access-decls-empty]
  gen-access-decls(type [ $TypeId, $Alt+, ]) =

[equ-gen-access-decls-divide]
  $Field = field [ $FieldId, $FieldType, $Loc+ ],
  build-has-decl($TypeId, $FieldType, $FieldId) = $FunDecl1,
  build-getter-decl($TypeId, $FieldType, $FieldId) = $FunDecl2,
  build-setter-decl($TypeId, $FieldType, $FieldId) = $FunDecl3,
  gen-access-decls(type [ $TypeId, $Alt+, $Field* ]) = $FunDeclList1,
  extern $FunDecl1; extern $FunDecl2; extern $FunDecl3; $FunDeclList1 = $FunDeclList2
  ===>
  gen-access-decls(type [ $TypeId, $Alt+, $Field $Field* ]) = $FunDeclList2

[equ-gen-term-decls]
  gen-term-decls(type [ $TypeId, $Alt+, $Field* ]) =
    extern build-c-id($TypeId) build-c-id(make $TypeId from term)(ATerm arg);
    extern ATerm build-c-id(make term from $TypeId)(build-c-id($TypeId) arg);

[equ-gen-source]
   gen-struct-decls($API) = $Typedef*,
   build-init-impl($Prefix)  = $InitImpl,
   gen-fun-impls($API)    = $FunImplList,
   build-api-header($Prefix) = $ApiHeader
   ===>
   gen-source($Prefix, $API) = 
     #include <stdio.h>@
     #include $ApiHeader@
     $Typedef*
     $InitImpl
     $FunImplList

[equ-gen-struct-decls-empty]
  gen-struct-decls(api [ ]) =

[equ-gen-struct-decls-divide]
  gen-struct-decl($Type) = $Typedef,
  gen-struct-decls(api [ $Type* ]) = $Typedef*
  ===>
  gen-struct-decls(api [ $Type $Type* ]) = $Typedef $Typedef*

[equ-gen-struct-decl]
  gen-struct-decl(type [ $TypeId, $Alt+, $Field* ]) = 
	typedef struct ATerm build-c-id(_ $TypeId);

[equ-gen-fun-impls-empty]
  gen-fun-impls(api [ ]) =

[equ-gen-fun-impls-divide]
  gen-term-impls($Type) = $FunImplList1,
  gen-constructor-impls-top($Type) = $FunImplList2,
  gen-valid-impl($Type) = $FunImplList3,
  gen-check-impls($Type) = $FunImplList4,
  gen-access-impls($Type) = $FunImplList5,
  gen-fun-impls(api [ $Type* ]) = $FunImplList6
  ===>
  gen-fun-impls(api [ $Type $Type* ]) = 
	$FunImplList1 $FunImplList2 $FunImplList3 
	$FunImplList4 $FunImplList5 $FunImplList6

[equ-gen-constructor-impls-top-single]
  gen-constructor-impls-top(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) =
	gen-constructor-impl-single($TypeId, $AltId, $Field*)

[default-gen-constructor-impls-top]
  gen-constructor-impls-top($Type) = gen-constructor-impls($Type)

[equ-gen-constructor-impls-single]
  gen-constructor-impls(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) = 
	gen-constructor-impl($TypeId, $AltId, $Field*)

[equ-gen-constructor-impls-divide]
  gen-constructor-impls(type [ $TypeId, $Alt, $Field* ]) = $FunImplList1,
  gen-constructor-impls(type [ $TypeId, $Alt+, $Field* ]) = $FunImplList2
  ===>
  gen-constructor-impls(type [ $TypeId, $Alt $Alt+, $Field* ]) = $FunImplList1 $FunImplList2

[equ-gen-constructor-impl-single]
  gen-constructor-decl-single($TypeId, $Field*) = $FunDecl,
  gen-constructor-body($TypeId, $AltId, $Field*) = $FunBody
  ===>
  gen-constructor-impl-single($TypeId, $AltId, $Field*) = $FunDecl { $FunBody }

[equ-gen-constructor-impl]
  gen-constructor-decl($TypeId, $AltId, $Field*) = $FunDecl,
  gen-constructor-body($TypeId, $AltId, $Field*) = $FunBody
  ===>
  gen-constructor-impl($TypeId, $AltId, $Field*) = $FunDecl { $FunBody }

[equ-gen-constructor-body]
  get-fields-for-alt($AltId, $Field*) = $AltField*,
  sort-fields($AltField*) = $SortedField*,  
  build-actual-args-list($SortedField*) = $ActualArg*
  ===>
  gen-constructor-body($TypeId, $AltId, $Field*) = 
	return (build-c-id($TypeId))ATmakeTerm(build-c-id(pattern $TypeId $AltId), 
                                               $ActualArg*);

[equ-gen-valid-impl]
  gen-valid-impl(type [ $TypeId, $Alt+, $Field* ]) =
    ATbool build-c-id(is valid $TypeId)(build-c-id($TypeId) arg) {
      gen-valid-body($TypeId, $Alt+)
    }

[equ-gen-valid-body-empty]
  gen-valid-body($TypeId, ) = { return ATfalse; }

[equ-gen-valid-body-divide]
  gen-valid-body($TypeId, $Alt*) = $Stat
  ===>
  gen-valid-body($TypeId, alt [ $AltId, $Pattern ] $Alt*) =
    if (build-c-id(is $TypeId $AltId)(arg)) {
       return ATtrue;
    } else $Stat

[equ-gen-check-impls-single]
  gen-check-impls(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) = 
	gen-check-impl($TypeId, $AltId, $Field*)

[equ-gen-check-impls-divide]
  gen-check-impls(type [ $TypeId, $Alt, $Field* ]) = $FunImplList1,
  gen-check-impls(type [ $TypeId, $Alt+, $Field* ]) = $FunImplList2
  ===>
  gen-check-impls(type [ $TypeId, $Alt $Alt+, $Field* ]) = $FunImplList1 $FunImplList2

[equ-gen-check-impl]
  build-check-decl($TypeId, $AltId) = $FunDecl,
  gen-check-body($TypeId, $AltId, $Field*) = $FunBody
  ===>
  gen-check-impl($TypeId, $AltId, $Field*) = $FunDecl { $FunBody }

[equ-gen-check-body]
  get-fields-for-alt($AltId, $Field*) = $AltField*,
  build-null-args-list($AltField*) = $ActualArg*
  ===>
  gen-check-body($TypeId, $AltId, $Field*) = 
	return ATmatchTerm(build-c-id(arg),
			   build-c-id(pattern $TypeId $AltId), 
			   $ActualArg*);

[equ-gen-access-impls-empty]
  gen-access-impls(type [ $TypeId, $Alt+, ]) =

[equ-gen-access-impls-divide]
  gen-has-impl($TypeId, $Field) = $HasImpl,
  gen-getter-impl($TypeId, $Field) = $GetImpl,
  gen-setter-impl($TypeId, $Field) = $SetImpl,
  gen-access-impls(type [ $TypeId, $Alt+, $Field* ]) = $FunImplList
  ===>
  gen-access-impls(type [ $TypeId, $Alt+, $Field $Field* ]) = 
	$HasImpl $GetImpl $SetImpl $FunImplList

[equ-gen-term-impls]
  build-c-id($TypeId) = $Id
  ===>
  gen-term-impls(type [ $TypeId, $Alt+, $Field* ]) =
    $Id build-c-id(make $TypeId from term)(ATerm arg) {
      return ($Id)arg;
    }
    ATerm build-c-id(make term from $TypeId)($Id arg) {
      return (ATerm)arg;
   }

[equ-build-init-decl]
  build-init-decl(c-file-name($Char*)) = 
	void build-c-id(init afun($Char*) api)()


[equ-build-init-impl]
  build-init-impl(c-file-name($Char*)) = 
	void build-c-id(init afun($Char*) api)() {
           build-c-id(afun("i" "n" "i" "t" "_" $Char* "_" "d" "i" "c" "t"))();
        }

[equ-build-check-decl]
  build-check-decl($TypeId, $AltId) =
    build-c-id(ATbool) build-c-id(is $TypeId $AltId) ( build-c-id($TypeId) arg )

[equ-gen-has-impl]
  build-has-decl($TypeId, $FieldType, $FieldId) = $FunDecl,
  gen-has-body($TypeId, $FieldType, $Loc+) = $FunBody
  ===>
  gen-has-impl($TypeId, field [$FieldId, $FieldType, $Loc+]) = $FunDecl { $FunBody }

[equ-gen-has-body-empty]
  gen-has-body($TypeId, $FieldType, ) = { return ATfalse; }

[equ-gen-has-body-divide]
  $Loc = loc [ $AltId, $Path ],
  $Stat = gen-has-body($TypeId, $FieldType, $Loc*)
  ===>
  gen-has-body($TypeId, $FieldType, $Loc $Loc*) = 
	if (build-c-id(is $TypeId $AltId)(arg)) {
	  return ATtrue;
        } else $Stat

[equ-gen-getter-impl]
  build-getter-decl($TypeId, $FieldType, $FieldId) = $FunDecl,
  gen-getter-body($TypeId, $FieldType, $Loc+) = $FunBody
  ===>
  gen-getter-impl($TypeId, field [$FieldId, $FieldType, $Loc+]) = $FunDecl { $FunBody }

[equ-gen-getter-body-empty]
  gen-getter-body($TypeId, $FieldType, ) = 
	{ 
	  ATabort("malformed term: %t\n", arg);
	  return NULL;
	}

[equ-gen-getter-body-divide]
  $Loc = loc [ $AltId, $Path ],
  $GetExpr = build-get-expr($Path, build-c-id(arg)),
  $Stat = gen-getter-body($TypeId, $FieldType, $Loc*)
  ===>
  gen-getter-body($TypeId, $FieldType, $Loc $Loc*) = 
	if (build-c-id(is $TypeId $AltId)(arg)) {
	  return (build-c-id($FieldType))$GetExpr; 
        } else $Stat

[equ-build-get-expr-empty]
  build-get-expr( , $GetExpr) = $GetExpr

[equ-build-get-expr-tail]
  $GetExpr2 = ATgetTail((ATermList)$GetExpr1, build-c-int($Index))
  ===>
  build-get-expr(tail:$Index -> $Path, $GetExpr1) = 
	build-get-expr($Path, $GetExpr2)

[equ-build-get-expr-elem]
  $GetExpr2 = ATelementAt((ATermList)$GetExpr1, build-c-int($Index))
  ===>
  build-get-expr(elem:$Index -> $Path, $GetExpr1) = 
	build-get-expr($Path, $GetExpr2)

[equ-build-get-expr-arg]
  $GetExpr2 = ATgetArgument((ATermAppl)$GetExpr1, build-c-int($Index))
  ===>
  build-get-expr(arg:$Index -> $Path, $GetExpr1) = 
	build-get-expr($Path, $GetExpr2)

[equ-build-has-decl]
  build-has-decl($TypeId, $FieldType, $FieldId) =
    ATbool build-c-id(has $TypeId $FieldId) ( build-c-id($TypeId) arg )

[equ-build-getter-decl]
  build-getter-decl($TypeId, $FieldType, $FieldId) =
    build-c-id($FieldType) build-c-id(get $TypeId $FieldId) ( build-c-id($TypeId) arg )

[equ-gen-setter-impl]
  build-setter-decl($TypeId, $FieldType, $FieldId) = $FunDecl,
  gen-setter-body($TypeId, $FieldType, $FieldId, $Loc+) = $FunBody
  ===>
  gen-setter-impl($TypeId, field [ $FieldId, $FieldType, $Loc+ ]) = $FunDecl { $FunBody }

[equ-gen-setter-body-empty]
  gen-setter-body($TypeId, $FieldType, $FieldId, ) = 
	{ 
	  ATabort("malformed term: %t\n", arg);
	  return NULL;
	}

[equ-gen-setter-body-divide]
  $Loc = loc [ $AltId, $Path ],
  $SetExpr = build-set-expr($FieldId, , $Path),
  $Stat = gen-setter-body($TypeId, $FieldType, $FieldId, $Loc*)
  ===>
  gen-setter-body($TypeId, $FieldType, $FieldId, $Loc $Loc*) = 
	if (build-c-id(is $TypeId $AltId)(arg)) {
	  return (build-c-id($TypeId))$SetExpr; 
        } else $Stat
  

[equ-build-set-expr-empty]
  build-set-expr($FieldId, $Parent, ) = (ATerm)build-c-id($FieldId)

[equ-build-set-expr-tail]
  $GetExpr = build-get-expr($Parent, build-c-id(arg)),
  $SetExpr1 = build-set-expr($FieldId, $Parent -> tail:$Index, $Path),
  $SetExpr2 = (ATerm)ATreplaceTail((ATermList)$GetExpr, (ATermList)$SetExpr1, build-c-int($Index))
  ===>
  build-set-expr($FieldId, $Parent, tail:$Index -> $Path) = $SetExpr2

[equ-build-set-expr-elem]
  $GetExpr = build-get-expr($Parent, build-c-id(arg)),
  $SetExpr1 = build-set-expr($FieldId, $Parent -> elem:$Index, $Path),
  $SetExpr2 = (ATerm)ATreplace((ATermList)$GetExpr, $SetExpr1, build-c-int($Index))
  ===>
  build-set-expr($FieldId, $Parent, elem:$Index -> $Path) = $SetExpr2

[equ-build-set-expr-arg]
  $GetExpr = build-get-expr($Parent, build-c-id(arg)),
  $SetExpr1 = build-set-expr($FieldId, $Parent -> arg:$Index, $Path),
  $SetExpr2 = (ATerm)ATsetArgument((ATermAppl)$GetExpr, $SetExpr1, build-c-int($Index))
  ===>
  build-set-expr($FieldId, $Parent, arg:$Index -> $Path) = $SetExpr2

[equ-build-setter-decl]
  build-setter-decl($TypeId, $FieldType, $FieldId) =
    build-c-id($TypeId) 
    build-c-id(set $TypeId $FieldId) ( build-c-id($TypeId) arg, 
                                       build-c-id($FieldType) build-c-id($FieldId) )

[equ-build-formal-args-list-empty]
  build-formal-args-list( ) =

[equ-build-formal-args-list-divide]
  build-c-id($FieldType) build-c-id($FieldId) = $FormalArg,
  build-formal-args-list($Field*) = $FormalArg*
  ===>
  build-formal-args-list(field [ $FieldId, $FieldType, $Loc+ ] $Field*) = 
	$FormalArg, $FormalArg*

[equ-build-actual-args-list-empty]
  build-actual-args-list( ) =

[equ-build-actual-args-list-divide]
  build-c-id($FieldId) = $ActualArg,
  build-actual-args-list($Field*) = $ActualArg*
  ===>
  build-actual-args-list(field [ $FieldId, $FieldType, $Loc+ ] $Field*) = 
	$ActualArg, $ActualArg*

[equ-build-null-args-list-empty]
  build-null-args-list( ) =

[equ-build-null-args-list-divide]
  build-null-args-list($Field*) = $ActualArg*
  ===>
  build-null-args-list(field [ $FieldId, $FieldType, $Loc+ ] $Field*) = 
	NULL, $ActualArg*

[equ-build-typedef]
  build-typedef($TypeId) =
        typedef struct build-c-id(_ $TypeId) * build-c-id($TypeId);

[equ-build-c-id-tail-single]
  capitalize($AFun) = afun($Char*)
  ===>
  build-c-id-tail ( $AFun ) = c-id($Char*)

[equ-build-c-id-tail-divide]
  build-c-id-tail ( $AFun ) = c-id($Char*1),
  build-c-id-tail ( $AFun+) = c-id($Char*2)
  ===>
  build-c-id-tail ( $AFun $AFun+ ) = c-id($Char*1 $Char*2)

[equ-build-c-id-multi]
  build-c-id-tail ( $AFun+ ) = c-id($Char*2)
  ===>
  build-c-id ( afun($Char*1) $AFun+ ) = c-id($Char*1 $Char*2)

[equ-build-c-id-single]
  build-c-id(afun($Char*)) = c-id($Char*)

[equ-build-c-int-zero] 
  build-c-int(zero) = 0

[equ-build-c-int-succ]
  build-c-int(succ($Nat)) = succ(build-c-int($Nat))

[equ-build-afun]
  build-c-id($AFun+) = c-id($Char*)
  ===>
  build-afun($AFun+) = afun($Char*)

[equ-build-header-tag]
  build-header-tag(c-file-name($Char*)) = c-file-tag($Char* "." "h" ":")

[equ-build-source-tag]
  build-source-tag(c-file-name($Char*)) = c-file-tag($Char* "." "c" ":")

[equ-build-dict-tag]
  build-dict-tag(c-file-name($Char*)) = c-file-tag($Char* "." "d" "i" "c" "t" ":")

[equ-build-dict-header]
  build-dict-header(c-file-name($Char*)) = 
	c-include-file(""" $Char* "_" "d" "i" "c" "t" "." "h" """)

[equ-build-api-header]
  build-api-header(c-file-name($Char*)) = c-include-file(""" $Char* "." "h" """)

[equ-build-macro]
  build-macro(c-file-name($Char*)) = c-id("_" "_" $Char* "_" "H")

[equ-gen-dict-empty]
  gen-dict(api [ $Type ]) = gen-dict-alts($Type)

[equ-gen-dict-divide]
  gen-dict-alts($Type) = $Dict1,
  gen-dict(api [ $Type+ ]) = $Dict2
  ===>
  gen-dict(api [ $Type $Type+ ]) = $Dict1, $Dict2

[equ-gen-dict-alts-single]
  gen-dict-alts(type [ $TypeId, alt [ $AltId, $Pattern ], $Field* ]) =
	[ build-afun(pattern $TypeId $AltId), replace-holes($Pattern) ]

[equ-gen-dicts-alts-divide]
  gen-dict-alts(type [ $TypeId, $Alt, $Field* ]) = $Dict1,
  gen-dict-alts(type [ $TypeId, $Alt+, $Field* ]) = $Dict2
  ===>
  gen-dict-alts(type [ $TypeId, $Alt $Alt+, $Field* ]) = $Dict1, $Dict2

[default-replace-holes]
  replace-holes($ATerm) = $ATerm

[equ-replace-holes-appl]
  replace-holes-terms($Args1) = $Args2
  ===>
  replace-holes($AFun($Args1)) = $AFun($Args2)

[equ-replace-holes-list]
  replace-holes-terms($Elems1) = $Elems2
  ===>
  replace-holes([$Elems1]) = [$Elems2]

[equ-replace-holes-placeholder]
  replace-placeholder(<$ATerm1>) = $ATerm2
  ===>
  replace-holes(<$ATerm1>) = $ATerm2

[equ-replace-holes-terms-empty]
  replace-holes-terms() =

[equ-replace-holes-terms-divide]
  replace-holes($ATerm1) = $ATerm2,
  replace-holes-terms($ATerms1) = $ATerms2
  ===>
  replace-holes-terms($ATerm1,$ATerms1) = $ATerm2,$ATerms2

[default-replace-placeholder]
  replace-placeholder(<$ATerm>) = <term>

[equ-replace-placeholder]
  replace-placeholder(<[$ATerm]>) = <list>
